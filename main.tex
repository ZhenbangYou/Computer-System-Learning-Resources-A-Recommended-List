\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{a4paper,left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
\usepackage{hyperref}
\usepackage{CJKutf8}
\usepackage{gbt7714}


\title{\Huge{Computer Systems Learning Resources}\\ \huge{A Recommendation List}}
\author{Zhenbang You}
\date{January 11, 2022}

\begin{document}

\maketitle

\centerline{\large{Last Updated: February 3, 2024}}

\vspace{20pt}

The latest version can always be found at \href{https://www.overleaf.com/read/txqjnjxyxqqx}{https://www.overleaf.com/read/txqjnjxyxqqx}

\section{Preliminary}

\textbf{Disclaimer}
\begin{itemize}
    \item This list focuses on \emph{breadth} rather than \emph{depth}.
    \item This text mainly focuses on \emph{software systems}, with less concentration on topics such as \emph{VLSI}, \emph{storage systems}, and \emph{embedded systems}, although these are mentioned in some of the following resources.
\end{itemize}

\noindent
\textbf{Directions}
\begin{itemize}
    \item The most fundamental components of computer systems are:
    \begin{enumerate}
        \item Computer Architecture
        \item Operating Systems (OS)
        \item Computer Networks
        \item Compilers
        \item Programming Languages (PL)
    \end{enumerate}
    Master them before moving on to other parts.
    
    Section 2-10 is the core of this list.
    \item The resources in each section are list in an order \emph{suitable for learning}.
    \begin{itemize}
        \item If time is limited, you may just read the first (or the first few) books, and move on to the next section.
        \item To understand some advanced books, knowledge of subsequent sections may be required.
    \end{itemize}
    \item The references help you identify the \emph{authors} rather than \emph{latest versions}.
    \item Given the rapid development of computer science, always read the latest version.
    \begin{itemize}
        \item Tip: search \emph{Amazon} for the latest version. The version number in this text may be outdated with new publications.
    \end{itemize}
\end{itemize}

\noindent
\textbf{How to Read a Book?}\\
Three passes.
\begin{enumerate}
    \item Fast: get the main idea and leave out all the details.
    \item Exhaustive: understanding the logic and virtually all the details; few really difficult points can be left out.
    \item Deep: raise questions, and focus on interesting or difficult points.
\end{enumerate}
Here is a famous paper called ``How to Read a Paper" which discusses a similar issue:\\
\href{https://web.stanford.edu/class/cs245/readings/how-to-read-a-paper.pdf}{https://web.stanford.edu/class/cs245/readings/how-to-read-a-paper.pdf}

~

\noindent
\textbf{Why do you recommend so many resources about application?}\\
Learn how to use it before learning how to build it.

~

\noindent
\textbf{Prerequisites}
\begin{itemize}
    \item CSAPP (3rd Edition) \cite{bryant2015computer}
    \item C/C++
    \item Data Structures and Algorithms
    \begin{itemize}
        \item Introduction to Algorithms (4th Edition) \cite{cormen2009introduction}.
    \end{itemize}
    \item Probability
    \begin{itemize}
        \item Elements of \emph{stochastic processes}, especially some basic conclusions and corollaries, are helpful.
    \end{itemize}
    \item Logic, Automata and Complexity
\end{itemize}

\noindent
\textbf{Special Note about Prerequisites}:

The motivation of specifying prerequisites is to help you figure out good learning roadmap.
Even if you do not satisfy prerequisites, you can still learn the topic; however, in this case, if you have difficulties during learning, you may refer to prerequisites to see whether you need learn something else first.

\noindent
\textbf{What if I want more?}
\begin{enumerate}
    \item Search for more courses offered by top universities.
    \begin{itemize}
        \item \textbf{How to find them?}
        \begin{enumerate}
            \item For a given university, search for its course list (note that the keyword you are searching for may not appear in the course names).\\
            Example:
            \begin{itemize}
                \item Stanford:
                \href{https://cs.stanford.edu/academicz/courses}{https://cs.stanford.edu/academicz/courses}
                \item UC Berkeley:
                \href{https://www2.eecs.berkeley.edu/Courses/CS/}{https://www2.eecs.berkeley.edu/Courses/CS/}
                \item MIT:
                \href{http://catalog.mit.edu/subjects/6/}{http://catalog.mit.edu/subjects/6/}
            \end{itemize}
            \item To save time by scanning the entire course list, you can find the curriculum or program sheet of the Bachelor's/Master's degree.\\
            Example:
            \begin{itemize}
                \item Stanford Computer Science Master's Program Sheets:\\
                \href{https://cs.stanford.edu/academicz/current-masters/masters-program-sheets/programsheets}{https://cs.stanford.edu/academicz/current-masters/masters-program-sheets/programsheets}
                \item UC Berkeley CS Major Degree Requirements (Undergraduate):
                \begin{enumerate}
                    \item Lower Division:\\
                    \href{https://eecs.berkeley.edu/resources/undergrads/cs/degree-reqs-lowerdiv}{https://eecs.berkeley.edu/resources/undergrads/cs/degree-reqs-lowerdiv}
                    \item Upper Division:\\
                    \href{https://eecs.berkeley.edu/resources/undergrads/cs/degree-reqs-upperdiv}{https://eecs.berkeley.edu/resources/undergrads/cs/degree-reqs-upperdiv}
                \end{enumerate}
            \end{itemize}
            \item The naming convention of course numbers helps you save time.
        \end{enumerate}
        Besides, courses provide \emph{practice} opportunities, which is key to learning computer systems.
    \end{itemize}
    
    \item Find cross-cutting areas like machine learning systems.
    You can always find cutting-edge technologies and research hotspots here.
    Besides, computer systems are extremely powerful when different modules work together.
    \begin{itemize}
        \item Again, searching for advanced courses helps you discover these areas!
    \end{itemize}
\end{enumerate}

\noindent
\textbf{How to Avoid Forgetting?}
\begin{itemize}
    \item Repetition (multiple passes)
    \item Practice
    \item Questioning
    \item Discussion
\end{itemize}

\section{Computer Architecture}
\begin{enumerate}
    \item Computer Organization and Design: The Hardware-Software Interface\\
    (5th Edition \cite{patterson2013computerMIPS}/RISC-V Edition \cite{pattersoncomputerRV}/ARM Edition \cite{patterson2016computerARM})
    \begin{itemize}
        \item The original version is based on MIPS.
        RISC-V version is recommended; after reading this version, you may proceed on ARM version which is a good book for learning ARM.
    \end{itemize}
    \item Digital Design and Computer Architecture\\
    (2nd Edition \cite{harris2015digitalMIPS}/RISC-V Edition \cite{harris2021digitalRV}/ARM Edition \cite{harris2015digitalARM})
    \begin{itemize}
        \item You may just read Chap 1-5.
        \item The original version is based on MIPS.
    \end{itemize}
    \item The RISC-V Reader An Open Architecture Atlas \cite{patterson2017risc}
    \item Computer Architecture: A Quantitative Approach (6th Edition) \cite{hennessy2018computer}
    \begin{itemize}
        \item You may leave out appendices the first time you read this book.
        \item Difficult as it may be, this book is just ``the second book for novices".
        If you want to have a deep understanding of a specific topic, do go to read official tutorials/documentations such as those of NVIDIA.
        \item When having some experiences on \emph{parallel computing}, read corresponding chapters of this book again, you will surely gain some new understanding.
        \item Based on my personal experiences, multiple passes are needed to gain thorough comprehension of this masterpiece.
    \end{itemize}
    \item RISC-V Privileged Architecture (slides)\\
    \href{https://riscv.org/wp-content/uploads/2018/05/riscv-privileged-BCN.v7-2.pdf}{https://riscv.org/wp-content/uploads/2018/05/riscv-privileged-BCN.v7-2.pdf}
    \begin{itemize}
        \item A wonderful slide on RISC-V privileged architecture, as well as the core problem ``what is the privileged architecture".
        \item The video of this lecture can be found at\\ \href{https://www.youtube.com/watch?v=fxLXvrLN5jA}{https://www.youtube.com/watch?v=fxLXvrLN5jA}
        \item Most of the books on computer architecture discuss little about \emph{privileged architecture}, resulting in great difficulties understanding the OS kernel.
        Always keep in mind that \emph{ISA} consists of both the unprivileged architecture and the privileged architecture.
    \end{itemize}
    \item RISC-V specifications:
    \href{https://riscv.org/technical/specifications/}{https://riscv.org/technical/specifications/}
    \begin{itemize}
        \item Elaborate specifications as they may be, they are indeed excellent books for both neophytes and specialists!
        \item Appendix A: RVWMO Explanatory Material of ``The RISC-V Instruction Set Manual Volume I: Unprivileged ISA" is a brilliant tutorial for \textbf{Memory Consistency}!
    \end{itemize}
    \item A New Golden Age for Computer Architecture (a Turing Lecture with full text)\\
    \href{https://cacm.acm.org/magazines/2019/2/234352-a-new-golden-age-for-computer-architecture/fulltext}{https://cacm.acm.org/magazines/2019/2/234352-a-new-golden-age-for-computer-architecture/fulltext}
    \begin{itemize}
        \item The famous Turing Lecture by Hennessy and Patterson.
        What wonderful insights of masters!
    \end{itemize}
    \item Prerequisites:
    \begin{itemize}
        \item PL
        \begin{itemize}
            \item Java.
        \end{itemize}
    \end{itemize}
    \item To practice you knowledge of computer architecture, there are basically two ways:
    \begin{itemize}
        \item VLSI,
        \item Parallel computing.
    \end{itemize}
\end{enumerate}

\section{Operating Systems (OS)}
\subsection{Principles of Operating Systems}
\begin{enumerate}
    \item Books
        \begin{enumerate}
        \item Operating Systems: Three Easy Pieces:
        \href{https://pages.cs.wisc.edu/~remzi/OSTEP/}{https://pages.cs.wisc.edu/~remzi/OSTEP/}
        \begin{itemize}
            \item Due to the research interest of the authors, this book puts much emphasis on File Systems.
            You may leave out some chapters of this part the first time you read it.
            \item This is just an introductory-level book, read more after finish this!
        \end{itemize}
        \item Operating Systems Principles \& Practice (2nd Edition)
        \begin{itemize}
            \item Four volumes:
            \begin{itemize}
                \item Volume I: Kernels and Processes \cite{anderson2014operating1}
                \item Volume II: Concurrency \cite{andersonoperating2}
                \item Volume III: Memory Management \cite{andersonoperating3}
                \item Volume IV: Persistent Storage \cite{andersonoperating4}
            \end{itemize}
        \end{itemize}
        \item Operating Systems Concepts (10th Edition) \cite{peterson1985operating}
        \begin{itemize}
            \item Very up-to-date.
            Can be an alternative to the previous one.
            You do not need to read both.
        \end{itemize}
        \item xv6 source and text:
        \href{https://pdos.csail.mit.edu/6.828/2021/xv6.html}{https://pdos.csail.mit.edu/6.828/2021/xv6.html}
        \begin{itemize}
            \item Hands-on experiences with a real OS is indispensable, and \textbf{xv6} is an excellent starting point!
        \end{itemize}    

        \item Supplemental books
        \begin{enumerate}
            \item Linux Kernel Development (4rd Edition) \cite{robert2018linux}
            \item Understanding the Linux Kernel (3rd Edition) \cite{bovet2005understanding}
            \item Linux Device Drivers (3rd Edition) \cite{rubini2001linux}
            \item Understanding Linux network internals (1st Edition) \cite{benvenuti2006understanding}
        \end{enumerate}

    \end{enumerate}
    
    \item Courses
    \begin{itemize}
        \item Lab-based
        \begin{enumerate}
            \item Stanford CS 140E Operating Systems Design and Implementation
            \begin{itemize}
                \item \textbf{Rust} version:
                \href{https://cs140e.sergio.bz/}{https://cs140e.sergio.bz/}
                \item \textbf{C} version:
                \href{https://github.com/dddrrreee/cs140e-22win}{https://github.com/dddrrreee/cs140e-22win}
            \end{itemize}
            Uniqueness:
            \begin{enumerate}
                \item ``This course differs from most OS courses in that it uses \textbf{real hardware} instead of a fake simulator, and almost all of the code will be written by you."
            \end{enumerate}        
            \item Stanford CS 240LX Advanced Systems Laboratory, Accelerated:\\
            \href{https://github.com/dddrrreee/cs140e-22win}{https://github.com/dddrrreee/cs140e-22win}
            
            Uniqueness:
            \begin{enumerate}
                \item ``Our code will run "bare-metal" (without an operating system) on the widely-used ARM-based raspberry pi."
            \end{enumerate}                    
        \end{enumerate}
        \item Paper-based
        \begin{enumerate}
            \item Stanford CS 240 Advanced Topics in Operating Systems:\\
            \href{http://web.stanford.edu/class/cs240/}{http://web.stanford.edu/class/cs240/}        
        \end{enumerate}

    \end{itemize}

    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
        \item Computer Architecture (in particular, privileged architecture)
        \end{enumerate}
        \item PL
        \begin{itemize}
        \item \textbf{Java}: JVM, GC, Thread, Monitor.
        \item \textbf{Go}: Goroutine, Channel, CSP (Communication Sequential Process), Asynchrony.
        \end{itemize}
    \end{itemize}
    \item \textbf{Suggestions}:
    \begin{itemize}
        \item four passes to learn \emph{OS}
            \begin{enumerate}
                \item How to use: user/programmer's perspective, top-down.
                This pass is assisted by CSAPP and resources about \emph{Linux Programming}.
                \item How to build (build a usable one): builder's perspective, bottom-up.
                \item How to design (build a good one if there is no compatibility issues): both perspectives.
                This pass can only be down with knowledge of all the major parts of computer systems.
                \item Advanced and cross-cutting issues:
                \emph{distributed systems}, \emph{cloud computing},...
            \end{enumerate}
        \item Always think about the interaction and cooperation between
        \begin{itemize}
            \item OS \& hardware,
            \item OS \& computer networks,
            \item OS \& PL,
            \item OS \& DB.
        \end{itemize}
        Also think about whether their boundary can be and should be redefined.
        
        \textbf{DO NOT} overfit \emph{Linux}!
        Not everything of it is reasonable and well-suited to the current need!
    \end{itemize}

\end{enumerate}

\subsection{Linux Programming}
\begin{enumerate}
    \item Linux man pages
    \begin{itemize}
        \item ``man" command in Linux shell, like ``man fork" or ``man 2 fork" where ``2" specifies the volume.
        \item Linux man pages online:
        \href{https://man7.org/linux/man-pages/}{https://man7.org/linux/man-pages/}
    \end{itemize}
    \item Advanced programming in the UNIX environment (3rd Edition) \cite{stevens1992advanced}
\end{enumerate}

\section{Computer Networks}
\begin{enumerate}
    \item Books
    \begin{enumerate}
        \item Computer Networking: A Top Down Approach (8th Edition) \cite{kurosecomputer}
        \item Supplementary (by W. Richard Stevens)
        \begin{itemize}
            \item UNIX Network Programming
            \begin{itemize}
                \item Volume 1, 3rd Edition: The Sockets Networking API \cite{stevens2018unixvolume1}
                \item Volume 2, 2nd Edition: Interprocess Communications \cite{richard1999unixvolume2}
            \end{itemize}
            \item TCP/IP Illustrated
            \begin{itemize}
                \item Volume 1: The Protocols (2nd Edition) \cite{fall2011tcp}
                \item Volume 2: The Implementation \cite{stevens1996tcp}
                \item Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols \cite{stevens2000tcp}
            \end{itemize}
        \end{itemize}        
    \end{enumerate}
    
    \item Courses
    \begin{enumerate}
        \item Stanford CS 144 Introduction to Computer Networking:
        \href{https://cs144.github.io/}{https://cs144.github.io/}
        \item Stanford CS 244 Advanced Topics in Networking:\\
        \href{https://2022-cs244.github.io/schedule/}{https://2022-cs244.github.io/schedule/}
        \item Stanford CS 249I The Modern Internet:
        \href{https://cs249i.stanford.edu/}{https://cs249i.stanford.edu/}
        \item Stanford CS 344 Topics in Computer Networks (a.k.a. Build an Internet Router):\\
        \href{https://cs344-stanford.github.io/}{https://cs344-stanford.github.io/}
    \end{enumerate}

    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
            \begin{enumerate}
            \item Operating Systems
            \end{enumerate}
        \item PL
        \begin{itemize}
            \item \textbf{Java}.
            \item \textbf{Python}: Similar but much simpler socket interface than POSIX.
            \item \textbf{Go}: RPC.
        \end{itemize}
    \end{itemize}
\end{enumerate}

\section{Compilers}

The position of compilers in computer systems:
\begin{enumerate}
    \item \emph{Compilers} and \emph{programming languages} jointly construct the foundation of \emph{software}.
    \item Techniques in several areas are heavily exploited in compilers:
    \begin{enumerate}
        \item Computer Architecture
        \item Programming Languages
        \item Theoretical Computer Science (automata, algorithms, data structures)
        \item Discrete Mathematics
        \item Algebra
    \end{enumerate}
    \item Compilers play important roles in hardware-software codesign, since they are the bridge between hardware and programming languages.
    \item Never regard compilers merely as translation tools from programming languages to assembly code. In a broad sense, any automatic technique can be viewed as part of compiler techniques (and automation is based on formalization).
\end{enumerate}

\begin{enumerate}
    \item Books
    \begin{enumerate}
        \item Compilers: Principles, Techniques and Tools (2nd Edition) \cite{aho2007compilers}
        \begin{itemize}
            \item ``Dragon Book".
            \item Well-known but a little obsolete; still wonderful for new-comers.
        \end{itemize}
        \item Modern Compiler Implementation in C \cite{appel2004modern}/Java (2nd Edition) \cite{appel2003modern}/ML \cite{appel1998modern}
        \begin{itemize}
            \item ``Tiger Book".
        \end{itemize}
        \item Advanced Compiler Design Implementation \cite{muchnick1997advanced}
        \begin{itemize}
            \item ``Whale Book".
        \end{itemize}
        \item Engineering a Compiler (2nd Edition) \cite{cooper2011engineering}    
        \item Essentials of Compilation: An Incremental Approach\\
            \href{https://jeapostrophe.github.io/courses/2018/spring/406/notes/book.pdf}{https://jeapostrophe.github.io/courses/2018/spring/406/notes/book.pdf}
        \item Implementing Funtional Languages: a tutorial\\
        \href{https://www.microsoft.com/en-us/research/wp-content/uploads/1992/01/student.pdf}{https://www.microsoft.com/en-us/research/wp-content/uploads/1992/01/student.pdf}
    \end{enumerate}
    
    \item Courses
    \begin{enumerate}
        \item Stanford CS 143 Compilers:
        \href{https://web.stanford.edu/class/cs143/}{https://web.stanford.edu/class/cs143/}
        \item Stanford CS 243 Program Analysis and Optimization:\\
        \href{https://suif.stanford.edu/~courses/cs243/}{https://suif.stanford.edu/~courses/cs243/}
        \item Stanford CS 343D Domain-Specific Programming Models and Compilers:\\
        \href{https://cs343d.github.io/}{https://cs343d.github.io/}
    \end{enumerate}

    \item Programming suggestions:
    \begin{enumerate}
        \item Try functional languages!\\
        \emph{Pattern matching}, \emph{combinators}, \emph{monadic design}, and powerful \emph{type systems} (in particular, \emph{algebraic data types}) are all your good friends!
        \item There are two kinds of (domain-specific) languages: internal and external, and the latter means a language embedded in another host language.
        It can be quite fun to write a compiler for an internal (domain-specific) language.
        Good choices for host languages: Scala, Haskell, C++.
    \end{enumerate}

    \item Parser Generators
    \begin{enumerate}
        \item C/C++: Lex \& Yacc \cite{levine1992lex}
        \item OCaml: OCamllex \& Menhir\\
        \href{https://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html}{https://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html}
        \item Haskell: Parser Combinators\\
        There are various of them in Haskell.\\
        Some tutorials:
        \begin{enumerate}
            \item Real World Haskell: \\
            \href{https://book.realworldhaskell.org/read/using-parsec.html}{https://book.realworldhaskell.org/read/using-parsec.html}
            \item Wikibook: \\
            \href{https://wiki.haskell.org/Parsing_a_simple_imperative_language}{https://wiki.haskell.org/Parsing\_a\_simple\_imperative\_language}
        \end{enumerate}
        \item F\#: FsLex \& FsYacc\\
        Tutorial from Wikibook:\\
        \href{https://en.wikibooks.org/wiki/F_Sharp_Programming/Lexing_and_Parsing}{https://en.wikibooks.org/wiki/F\_Sharp\_Programming/Lexing\_and\_Parsing}
        \item Scala: Scala Parser Combinators\\
        \href{https://github.com/scala/scala-parser-combinators}{https://github.com/scala/scala-parser-combinators}
        \item ANTLR\\
        \href{https://www.antlr.org/about.html}{https://www.antlr.org/about.html}
    \end{enumerate}
    These tools are convenient, but writing lexers and parsers manually is also a lot of fun!
    \begin{enumerate}
        \item A tutorial about writing parser generators manually in Scala:
        Chapter 9, Functional Programming in Scala
        \cite{chiusano2014functional}
    \end{enumerate}

    \item LLVM
    \begin{enumerate}
        \item Kaleidoscope Tutorial\\
        \href{https://llvm.org/docs/tutorial/index.html}{https://llvm.org/docs/tutorial/index.html}
        \item LLVM Documentation Home\\
        \href{https://llvm.org/docs/}{https://llvm.org/docs/}
        \item LLVM for Graduate Student\\
        \href{https://www.cs.cornell.edu/~asampson/blog/llvm.html}{https://www.cs.cornell.edu/~asampson/blog/llvm.html}
    \end{enumerate}    
    Special note: renowned as LLVM is, it is indeed not very convenient. Besides, its APIs lack back compatibility.

    Apart from C/C++, LLVM also has bindings for other languages like OCaml, Haskell, Rust, Go, C\#, F\#, Node.js, Go, Python.

    \item Some interesting open-source compiler-related projects:
    \begin{enumerate}
        \item Halide/TVM
        \item TACO
        \item LLVM/MLIR
        \item XLA
        \item QEMU
    \end{enumerate}

    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
        \item Computer Architecture: ILP (Instruction-Level Parallelism), Memory Hierarchy
        \begin{enumerate}
            \item This is compulsory only when you want to learn compiler optimizations.
        \end{enumerate}
        
    \end{enumerate}
        \item Recommended:
        \begin{enumerate}
            \item TCS (Theoretical Computer Science)
            \begin{enumerate}
            \item Introduction to the Theory of Computation (3rd Edition) \cite{sipser1996introduction}
            \begin{itemize}
                \item Chapter 1 and 2 are enough.
                For compilers, understanding how to use these automata is enough.
                No need to worry about proofs.
            \end{itemize}
        \end{enumerate}
            \item Computer Architecture: DLP (Data-Level Parallelism), TLP (Thread-Level Parallelism)
            \item Operating Systems: Thread, Context Switch
        \end{enumerate}
        \item PL
        \begin{itemize}
            \item \textbf{Java}.
        \end{itemize}
    \end{itemize}
\end{enumerate}

\section{Programming Languages (PL)}

When talking about \emph{PL}, we are actually dealing with two things:
\begin{itemize}
    \item programming,
    \item verification.
\end{itemize}

\noindent Abbreviations:
\begin{itemize}
    \item OOP: Object-Oriented Programming
    \item FP: Functional Programming
\end{itemize}

\subsection{Language List}

\subsubsection{Programming Language List}

\textbf{Suggestions for Learning Order}

\begin{enumerate}
    \item Start with functional languages, since they do not need to take \emph{memory} into account, which is always confusing and error-prone for beginners.
    Besides, functional programming lets you pay more attention to the description of computation rather than its implementation; this is really a blessing.
    \item Which functional language to choose?
    \begin{enumerate}
        \item \emph{Lisp} family is too stale and outdated.
        \item Purely functional languages like \emph{Haskell} is also not appropriate.
        Think about the effort needed to understand \emph{monad}!
        \item \emph{Scala} is not good too, due to its complex syntax, although being fairly modern.
        \item The only remaining choice seems to be \emph{ML} family, of which \emph{OCaml} and \emph{F\#} are both great. \emph{F\#} is more modern and easier to learn, and the OOP in F\# is more mature.
        \item However, starting from \emph{ML} family sounds a little horrendous.
        \item Consider learning \emph{Kotlin} first, for its simplicity and modernity, and being functional enough except the lack of full support for pattern matching.
    \end{enumerate}
    \item With the foundations of \emph{Kotlin} and \emph{OCaml/F\#}, it is easy to learn virtually all the mainstream languages like \emph{Java}, \emph{TypeScript}, and even \emph{Scala} (although this one obviously requires more effort than the previous two); besides, you can also advance towards \emph{Rust} (time-consuming!), and after that, the legendary \emph{C++}.
    If \emph{Rust} is too hard for you, try \emph{Go} first.
\end{enumerate}


\textbf{Tips}
\begin{enumerate}
    \item \textbf{General tips for choosing an IDE}:
    \begin{enumerate}
        \item For languages running on \emph{JVM}, choose \emph{JetBrains}.
        \item If \emph{JetBrains} has a specific software for the language your target language, prefer it.
        \item Otherwise, \emph{VS Code} is always a nice choice.
    \end{enumerate}
        Only IDEs I have used will be listed here, so there may be other wonderful IDEs.
    \item \textbf{General tips for choosing platforms for \emph{Windows} users}:
    \begin{enumerate}
        \item For languages on \emph{.NET}, \emph{Windows} is obviously the best.
        \item Otherwise, \emph{WSL2} is at least not worse than \emph{Windows}.
        \item For old AOT (ahead-of-time) compiled languages like \emph{C/C++}, \emph{OCaml}, \emph{Windows} may be a disaster (lots of compatibility issues).
        \item For JIT (just-in-time) compiled languages and modern AOT compiled languages such as \emph{Go} and \emph{Rust}, it does not matter which one you choose (luckily, \emph{Haskell} is also good on \emph{Windows}).
        \item \emph{Python} is a special case where the compatibility of \emph{Windows} is not good enough sometimes for some packages.
    \end{enumerate}
    \item \textbf{Development toolchains matter.}
    
    You need not only \emph{compilers}, \emph{libraries} and \emph{IDE}, but also \emph{build tools}, \emph{debuggers}, \emph{test tools}, \emph{linters}, and even \emph{sanitizers}, \emph{profilers}, \emph{formatters}, etc.
    
    \item \textbf{Frameworks} are key components of the ecosystem of a PL.
    Success of some PL highly relies on the its frameworks.
    \item Sometimes \textbf{searching within a tutorial/documentation} gives better answer than \emph{Google}.
    \item Unless specified explicitly, always try the latest version.
\end{enumerate}

\begin{itemize}
    \item \textbf{C/C++} (Do learn the latest version of C++, or at least C++17)
    
    If possible, learn \emph{Rust} first.
    
    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item The C Programming Language (2nd Edition) \cite{ritchie1988c}
            \begin{itemize}
                \item ``\textbf{K \& R}"
            \end{itemize}
            \item The C++ Programming Language (4th Edition) \cite{stroustrup2013c++}
        \end{enumerate}
        \item Documentations
        \begin{enumerate}
            \item \href{https://cppreference.com/}{https://cppreference.com/}
            \item Boost C++ Libraries:
            \href{https://www.boost.org/}{https://www.boost.org/}
        \begin{itemize}
            \item Sometime \emph{standard C++ libraries} are not enough.
            In this case, \emph{Boost} may provide additional useful functionality.
            Besides, some functionality of \emph{Boost} may be incorporated into \emph{standard C++ libraries} in the future, as the past shows.
        \end{itemize}
        \end{enumerate}

        \item Programming guidelines
        \begin{itemize}
            \item Scott Meyers ``Effective C++" book series
            \begin{itemize}
                \item Effective C++ (3rd Edition) \cite{meyers2005effective}
                \item Effective Modern C++ (1st Edition) \cite{meyers2014effective}
                \item Effective STL (1st Edition) \cite{meyers2001effective}
            \end{itemize}
            \item C++ Core Guidelines:\\ \href{https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines}{https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines}
        \end{itemize}
        \item Recommended IDE: VSCode on Linux (especially WSL).
        \item Recommended compilers: \emph{latest} GCC and Clang.
        \begin{itemize}
            \item Currently, \textbf{OpenMP} support of \textbf{Clang 13} needs to be installed separately, which is not the case for \textbf{Clang 12}.
            \item \textbf{GCC} can be built from source.
            \begin{itemize}
                \item Source code address:
                \href{https://github.com/gcc-mirror/gcc/tags}{https://github.com/gcc-mirror/gcc/tags}
            \end{itemize}
            \item \textbf{Clang} can by downloaded directly from \href{https://releases.llvm.org/download.html}{https://releases.llvm.org/download.html}
        \end{itemize}
        \item Build tool: 
        \begin{itemize}
            \item CMake (also works for CUDA C++).
                \begin{itemize}
                \item \textbf{CMake} Tutorial:
                \href{https://cmake.org/cmake/help/latest/guide/tutorial/}{https://cmake.org/cmake/help/latest/guide/tutorial/}
                \end{itemize}
            \item GNU make:
            \href{https://www.gnu.org/software/make/manual/make.html}{https://www.gnu.org/software/make/manual/make.html}
        \end{itemize}
        
        \item \textbf{GoogleTest} User’s Guide:
        \href{https://google.github.io/googletest/}{https://google.github.io/googletest/}
        \item Linter: \textbf{Clang-Tidy}:
        \href{https://clang.llvm.org/extra/clang-tidy/}{https://clang.llvm.org/extra/clang-tidy/}
        \begin{itemize}
            \item The coding style of C/C++ is much more important than that of other languages, due to the legacy, the flexibility and the safety issues of this language.
        \end{itemize}
        \item IDE setup guidelines:
        \begin{enumerate}
            \item VSCode. For Windows user, choose WSL.
            \item Latest G++/Clang++.
            \item VSCode extension: Clangd.
            \item Two files: .clang-format, .clang-tidy.
            \item compiledb (to ensure the intellisense works).
            \item Makefile (can be generated by CMake).
        \end{enumerate}
    \end{itemize}
    
    
    \item \textbf{Java} (Java 17 is recommended, or at least, choose an LTS version)
    
    \textbf{Consider learning Kotlin first}.
    
    Prerequisite languages: none.\\
    Pay attention to the comparison with C++, as well as JVM and JIT.
    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item Oracle online tutorial:
        \href{https://docs.oracle.com/javase/tutorial/}{https://docs.oracle.com/javase/tutorial/}
            \item Core Java (10th Edition). Two volumes:
            \begin{itemize}
                \item Volume I: Fundamentals \cite{gvero2013core1}
                \item Volume II: Advanced Features \cite{tarimci2014core2}
            \end{itemize}

        \end{enumerate}
        \item Documentations
        \begin{enumerate}
            \item \href{https://docs.oracle.com/javase/specs/}{https://docs.oracle.com/javase/specs/}
        \end{enumerate}
        \item Programming guidelines
        \begin{itemize}
            \item Effective Java (3rd Edition) \cite{bloch2008effective}
        \end{itemize}

        \item GraalVM:
        \href{https://www.graalvm.org/}{https://www.graalvm.org/}

        \item Recommended IDE: IntelliJ Idea
        \item Build tool (applying to all languages on JVM) : \textbf{Maven} or \textbf{Gradle}.
        \begin{itemize}
            \item Maven in 5 Minutes:\\
            \href{https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html}{https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html}
            \item All documentations can be found at:\\
            \href{https://maven.apache.org/}{https://maven.apache.org/}
            \item Try \textbf{Maven} with \textbf{IntelliJ Idea}.
        \end{itemize}
        \item \textbf{Spring}:
        \href{https://spring.io/quickstart}{https://spring.io/quickstart}
    \end{itemize}
    
    \item \textbf{C\#}
    
    For the sake of learning, C\# is a (much) better alternative Java, and it is also the key to .NET ecosystem.
    \begin{enumerate}
        \item Microsoft C\# documentation:
        \href{https://learn.microsoft.com/en-us/dotnet/csharp/}{https://learn.microsoft.com/en-us/dotnet/csharp/}
    \end{enumerate}

    \item \textbf{Scala} (\emph{Scala 3} is out!)\\
    
    \emph{Scala} borrows more from \emph{Haskell} than \emph{OCaml}.
    
    Prerequisite languages: none (if you find \emph{Scala} too difficult to learn, try \emph{Kotlin} first).
    
    Noteworthy features: FP.
    
    Multi-paradigmatic languages like \emph{Scala}, \emph{OCaml} and \emph{F\#} are great starting points to learn \emph{functional programming}, since your programming style can transition gradually from \emph{imperative programming} to \emph{functional programming}.
    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item Tour of Scala:
            \href{https://docs.scala-lang.org/tour/tour-of-scala.html}{https://docs.scala-lang.org/tour/tour-of-scala.html}
            \item Scala Book:
            \href{https://docs.scala-lang.org/overviews/scala-book/introduction.html}{https://docs.scala-lang.org/overviews/scala-book/introduction.html}

        \end{enumerate}
        \item Documentations
        \begin{itemize}
            \item Guides and Overviews:
            \href{https://docs.scala-lang.org/overviews/index.html}{https://docs.scala-lang.org/overviews/index.html}
            \item All documentations:
            \href{https://docs.scala-lang.org/}{https://docs.scala-lang.org/}
                \begin{itemize}
                    \item \emph{Scala 3} documentations can also be found here!
                \end{itemize}
        \end{itemize}
        \item Recommended IDE \& build tool: same as \emph{Java}
        \item For PL study, try \emph{Scala 3}.
        For the sake of ecosystem, currently \emph{Scala 2} is preferred.
        \end{itemize}
        
    \item \textbf{Kotlin}
    
    In my mind, it is the best language for entry-level programmers.
    
    Prerequisite languages: none.
    
    Try \emph{Scala} and \emph{Kotlin} together.
    
    Noteworthy features: null safety, modest FP.
    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item Get started with Kotlin:
            \href{https://kotlinlang.org/docs/getting-started.html}{https://kotlinlang.org/docs/getting-started.html}
            \item Kotlin Coroutines:\\
            \href{https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md}{https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md}
            \begin{itemize}
                \item Wonderful article about the design of stackless coroutines!
            \end{itemize}
        \end{enumerate}
        \item Documentations
        \begin{enumerate}
            \item        \href{https://kotlinlang.org/docs/}{https://kotlinlang.org/docs/}
        \end{enumerate}
        \item Recommended IDE \& build tool: same as \emph{Java}
    \end{itemize}
    
    \item \textbf{Go} (\emph{Go 1.18} with \emph{generics} is out!)\\
    Prerequisite languages: none.\\
    Noteworthy features: concurrent programming (goroutine + channel + asynchrony, GMP model), modest OOP (compare the OOP of Java and the OOP of Go).
    \begin{itemize}
        \item Turorials
        \begin{enumerate}
            \item A Tour of Go:
            \href{https://go.dev/tour/welcome/1}{https://go.dev/tour/welcome/1}
            \item Effective Go:
            \href{https://go.dev/doc/effective\_go}{https://go.dev/doc/effective\_go}
            \item Official tutorials (including those for generics, fuzzing and accessing a relational databases:
            \href{https://go.dev/doc/tutorial/}{https://go.dev/doc/tutorial/}
        \end{enumerate}
        \item Documentations
        \begin{enumerate}
            \item All the documentations can be found at:
            \href{https://go.dev/doc/}{https://go.dev/doc/}
        \end{enumerate}
        \item Blogs
        \begin{itemize}
            \item The Go Blog:
            \href{https://go.dev/blog/}{https://go.dev/blog/}
            \begin{itemize}
                \item Lots of wonderful articles about the design of Go!\\
                For example, ``Getting to Go: The Journey of Go's Garbage Collector":\\
                \href{https://go.dev/blog/ismmkeynote}{https://go.dev/blog/ismmkeynote}
            \end{itemize}    
            \item Russ Cox's Blog:
            \href{https://research.swtch.com/}{https://research.swtch.com/}
            \begin{itemize}
                \item There are not only lots of brilliant blogs about go, but other interesting topics!
            \end{itemize}
        \end{itemize}
        \item Recommended IDE: GoLand, VSCode
        \item Build tool:
        \href{https://go.dev/doc/modules/gomod-ref}{https://go.dev/doc/modules/gomod-ref}
    \end{itemize}
    
    \item \textbf{Rust}
    
    \emph{A extremely high-performance, memory-safe language without garbage collection}
    
    Most of the features of Rust can be found in either \emph{C++} or \emph{OCaml}; therefore, solid foundations of these two languages does help you understand the design of Rust.
    
    Which one to learn first, C++ or Rust?
    Due to the popularity of C++, most people were exposed to it before hearing of Rust.
    However, the design of Rust is more consistent and cleaner, less prone to be misused, also without the horrendous legacy of C++.
    Thus, I believe Rust is worth learning before C++.
    
    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item The Rust Programming Language:
            \href{https://doc.rust-lang.org/book/}{https://doc.rust-lang.org/book/}
            \begin{itemize}
                \item Also a good book about the design of programming languages!
            \end{itemize}
            \item Rust by Example:
            \href{https://doc.rust-lang.org/stable/rust-by-example/}{https://doc.rust-lang.org/stable/rust-by-example/}
            \item Asynchronous Programming in Rust:
            \href{https://rust-lang.github.io/async-book/}{https://rust-lang.github.io/async-book/}
            \item The Rustonomicon:
            \href{https://doc.rust-lang.org/nomicon/}{https://doc.rust-lang.org/nomicon/}
            \begin{itemize}
                \item This book is about ``Unsafe Rust".
            \end{itemize}
        \end{enumerate}
        \item Courses
        \begin{enumerate}
            \item CS 110L Safety in Systems Programming:\\
            \href{https://web.stanford.edu/class/cs110l/}{https://web.stanford.edu/class/cs110l/}
        \end{enumerate}
        \item Documentations
        \begin{enumerate}
            \item The Rust Reference:
            \href{https://doc.rust-lang.org/reference/}{https://doc.rust-lang.org/reference/}
            \item \href{https://doc.rust-lang.org/beta/}{https://doc.rust-lang.org/beta/}
        \end{enumerate}
        \item Lots of excellent books can be found at:\\
        \href{https://www.rust-lang.org/learn}{https://www.rust-lang.org/learn}
        \item Recommended IDE: VSCode, IntelliJ Idea
        \begin{itemize}
            \item Personnaly, I prefer \emph{VSCode}, in that its analyzer runs faster and does better in type inference.
        \end{itemize}
        \item Some nice crates (Rust's name for packages):
        \begin{enumerate}
            \item Thread-level parallelism:
            rayon.
            \item Asynchronous programming:
            futures + tokio/async-std/smol.
        \end{enumerate}
        \item Build Tool: Cargo.
        \begin{itemize}
            \item The Cargo Book:
            \href{https://doc.rust-lang.org/cargo/}{https://doc.rust-lang.org/cargo/}
            \item Its tutorial can also be found in ``The Rust Programming Language".
        \end{itemize}
    \end{itemize}

    \item \textbf{OCaml} (\emph{OCaml} 5.0 with \emph{multicore support} has been released!)
    
    \emph{ML}, the ancestor of \emph{OCaml}, is a programming language that won his creator a Turing Award, for it is ``the first language to include polymorphic type inference together with a type-safe exception-handling mechanism".
    
    Prerequisite languages: none.\\
    Familiarity with \emph{Scala} is very helpful.
    
    Comparison with \emph{Scala}:
    \begin{enumerate}
        \item \emph{Scala} is more like a hybrid of \emph{imperative programming} and \emph{functional programming}.
        However, \emph{functional programming} and \emph{imperative programming} take the primary and secondary positions in \emph{OCaml} respectively.
        
        \item \emph{Type inference} of \emph{OCaml} is even more powerful than that of \emph{Scala}, e.g., in \emph{Scala}, you need to specify the types of function arguments and the return types of recursive functions.
        
        \item \emph{Scala} allows \emph{implicit casting}, which is absolutely impossible in \emph{OCaml}.
        The type system of \emph{OCaml} is rather strict and rigor.
    \end{enumerate}
    If you have learned either one of them, I strongly recommend you learn the other.
    
    \begin{itemize}
        \item Tutorials:
        \begin{enumerate}
            \item Real World OCaml:
            \href{https://dev.realworldocaml.org/}{https://dev.realworldocaml.org/}
            \begin{itemize}
                \item \emph{OCaml} is one of few PL that attach great importance to \textbf{performance}, which is especially rare in \emph{functional language}.
                Fortunately, this book also gives introduction to the implementation of \emph{OCaml}, in particular, temporal and spatial cost.
                These contents are really instructive, in that functional programmers often know little about these.
                \item This book is written by people at Jane Street.
                Therefore, the book turns out to be practical rather than theoretical or mathematical as you may expect books about FP will do.
            \end{itemize}
            \item The OCaml Manual:
            \href{https://v2.ocaml.org/manual/index.html}{https://v2.ocaml.org/manual/index.html}            
            \item The official tutorial and documentation:
            \href{https://ocaml.org/docs}{https://ocaml.org/docs}
        \end{enumerate}
        \item Courses:
        \begin{itemize}
            \item Cornell CS 3110
            Functional Programming in OCaml:\\
            \href{https://cs3110.github.io/textbook/cover.html}{https://cs3110.github.io/textbook/cover.html}
            \item Harvard CS 51
            Abstraction and Design in Computation:\\
            \href{https://cs51.io/}{https://cs51.io/}
        \end{itemize}
        \item Build tool:
        \emph{dune}.
        \begin{itemize}
            \item \href{https://dune.readthedocs.io/en/stable/}{https://dune.readthedocs.io/en/stable/}
        \end{itemize}
        \item Package manager and version management tool: \emph{opam}.
        \item Recommended IDE:
        VSCode
        \item Notes:
        \begin{enumerate}
            \item If you are using Windows, please consider WSL2 for \emph{OCaml}.
        \end{enumerate}
    \end{itemize}
    
    \item \textbf{F\#}
    
    \emph{F\#} is quite similar to \emph{OCaml}, and it runs on the \emph{.NET} platform.
    Due to their similarity, once you have mastered either of them, it will be easy to learn the other.
    
    \emph{Which one to learn first? OCaml or F\#?}
    
    Either can be a good choice. For beginners, they are both good alternatives to each other. F\# is more modern, thus handier and free from the stale syntax of OCaml.

    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item Beginning F\# (Video Series):\\
            \href{https://www.youtube.com/playlist?list=PLdo4fOcmZ0oUFghYOp89baYFBTGxUkC7Z}{https://www.youtube.com/playlist?list=PLdo4fOcmZ0oUFghYOp89baYFBTGxUkC7Z}
            \item F\# for Fun and Profit:\\
            \href{https://fsharpforfunandprofit.com/site-contents/}{https://fsharpforfunandprofit.com/site-contents/}
            \item F\# Language Guide:
            \href{https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/}{https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/}
        \end{enumerate}
        \item Other learning materials
        \begin{enumerate}
            \item F\# Software Foundation:\\
            \href{https://fsharp.org/learn/}{https://fsharp.org/learn/}
            \item Microsoft:\\
            \href{https://dotnet.microsoft.com/en-us/learn/fsharp}{https://dotnet.microsoft.com/en-us/learn/fsharp}
        \end{enumerate}
        \item Documentations
        \begin{enumerate}
            \item F\# documentation:\\
        \href{https://docs.microsoft.com/en-us/dotnet/fsharp/}{https://docs.microsoft.com/en-us/dotnet/fsharp/}
        \end{enumerate}
        \item F\# has nice support for asynchronous and concurrent programming:
        \begin{itemize}
            \item \emph{async}:\\
            \href{https://learn.microsoft.com/en-us/dotnet/fsharp/tutorials/async}{https://learn.microsoft.com/en-us/dotnet/fsharp/tutorials/async}
            \item \emph{task}:\\
            \href{https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/task-expressions}{https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/task-expressions}
            \item \emph{MailboxProcessor} (actor model):\\
            \href{https://fsharpforfunandprofit.com/posts/concurrency-actor-model/}{https://fsharpforfunandprofit.com/posts/concurrency-actor-model/}
        \end{itemize}
        \item Recommended IDE: VSCode
    \end{itemize}

    \item \textbf{Haskell}\\
    \emph{GHC} recommended.
    
    \emph{Purely functional language}.\\

    Notable features:
    \begin{enumerate}
        \item purity \& laziness,
        \item type class \& type system,
        \item monad \& algebraic design.
    \end{enumerate}
    
    Knowledge of \emph{programming language theory} does help. Personally, I could not understand some of the most elegant design until taking Stanford CS 242.

    Elementary knowledge of \emph{abstract algebra} helps a lot for learning algebraic design in Haskell.
    
    Prerequisite languages: none.\\
    Recommended learning order:
    \emph{OCaml/F\#} $\rightarrow$ \emph{Scala} $\rightarrow$ \emph{Haskell}.
    
    Key differences between \emph{OCaml} and \emph{Haskell}:
    \begin{enumerate}
        \item Purity,
        \item Laziness.
        \item Haskell has a far more complex and advanced type system, while OCaml has a more complex module system.
    \end{enumerate}
    
    \emph{Haskell} is known for its steep learning curve, an appropriate learning order provides you sufficient foundations to conquer it.
    \begin{itemize}
        \item Tutorials
        \begin{enumerate}
            \item Learn You a Haskell for Great Good!:
            \href{http://learnyouahaskell.com/chapters}{http://learnyouahaskell.com/chapters}
            \begin{itemize}
                \item For beginners, this one is better than Real World Haskell.
            \end{itemize}\
            \item Real World Haskell:
            \href{http://book.realworldhaskell.org/read/}{http://book.realworldhaskell.org/read/}
            \item \emph{Wikibooks} has really nice passages about Haskell, including tutorials for beginners and advanced topics for experienced Haskell programmers:\\
            \href{https://en.wikibooks.org/wiki/Haskell}{https://en.wikibooks.org/wiki/Haskell}
            \item \emph{HaskellWiki} is really helpful.
        \end{enumerate}
        \item All the books, courses, tutorials, documentations and various kinds of resources can be found at:
        \href{https://www.haskell.org/documentation/}{https://www.haskell.org/documentation/}
        \item Frequently used websites:
        \begin{itemize}
            \item Hackage
            \item HaskellWiki
            \item Wikibook
            \item Hoogle
        \end{itemize}
        \item GHC User’s Guide:\\
        \href{https://downloads.haskell.org/ghc/latest/docs/users_guide}{https://downloads.haskell.org/ghc/latest/docs/users\_guide}
        \begin{itemize}
            \item GHC has many important extensions that can be found here.
        \end{itemize}
        \item Toolchain management tool: \emph{GHCup}
        \begin{itemize}
            \item Do not change the version of any tool outside ghcup!
            \item To make \emph{VSCode} work for us, the version of \emph{GHC} specified in \emph{stack} must be compatible with the \emph{GHC} versions supported by the \emph{Haskell Language Server}, and this specific version of \emph{GHC} should be installed within \emph{GHCup}, though it is not necessary to set it as default.
            Besides, the latency of initialization when opening a project is substantial, thus patience required.
        \end{itemize}
        \item Build tools:
        \begin{itemize}
            \item Stack (\textbf{preferred}):
            \href{https://docs.haskellstack.org/en/stable/}{https://docs.haskellstack.org/en/stable/}
            \begin{itemize}
                \item Most of the time you just need to deal with stack.
            \end{itemize}
            \item Cabal (\textbf{not recommended}):
            \href{https://www.haskell.org/cabal/}{https://www.haskell.org/cabal/}
            
        \end{itemize}
        \item The type system of Haskell is a nice example to study \emph{Curry-Howard Isomorphism}. Here is a great article about this:\\
        \href{https://en.wikibooks.org/wiki/Haskell/The_Curry%E2%80%93Howard_isomorphism#:~:text=The%20Curry%E2%80%93Howard%20isomorphism%2C%20hereafter,value%20that%20has%20that%20type.}{https://en.wikibooks.org/wiki/Haskell/The\_Curry\%E2\%80\%93Howard\_isomorphism\\
        #:~:text=  The\%20Curry\%E2\%80\%93Howard\%20isomorphism\%2C\%20hereafter,value\\
        \%20that\%20has\%20that\%20type.
        }
        \item A History of Haskell:\\
        \href{https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf}{https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf}
        
        \item Recommended IDE: VSCode
        \item Notes:
            \begin{enumerate}
                \item If you are using Windows, please consider WSL2 for \emph{OCaml}.
            \end{enumerate}
    \end{itemize}    
    \item \textbf{JavaScript/TypeScript/AssemblyScript}\\
    Prerequisite languages: none.\\
    The improvement of \emph{TypeScript} over \emph{JavaScript} is well worth studying.\\
    Pay attention to its \emph{asynchronous programming} techniques:
    \begin{enumerate}
        \item callbacks,
        \item promises (async), await.
    \end{enumerate}
\begin{itemize}
    \item Tutorials   
    \begin{enumerate}
        \item W3Schools JavaScript tutorial:
        \href{https://www.w3schools.com/js/}{https://www.w3schools.com/js/}
        \item JavaScript at the Mozilla Web Docs:\\
        \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide}{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide}
        \item W3Schools TypeScript tutorial:
        \href{https://www.w3schools.com/typescript/}{https://www.w3schools.com/typescript/}
        \item The TypeScript Handbook:\\
        \href{https://www.typescriptlang.org/docs/handbook/intro.html}{https://www.typescriptlang.org/docs/handbook/intro.html}
        \item Node.js official tutorial:
        \href{https://nodejs.dev/learn}{https://nodejs.dev/learn}
        \item The AssemblyScript Book:\\
        \href{https://www.assemblyscript.org/introduction.html}{https://www.assemblyscript.org/introduction.html}
    \end{enumerate}
    \item Books
    \begin{enumerate}
        \item JavaScript: The Good Parts
        \cite{crockford2008javascript}
    \end{enumerate}
    \item Documentations
    \begin{itemize}
        \item JavaScript: MDN Web Docs
        \item TypeScript Documentation:
        \href{https://www.typescriptlang.org/docs/}{https://www.typescriptlang.org/docs/}
    \end{itemize}
    \item Recommended IDE: VSCode
    \item Resources related to \emph{WASM} can be found \emph{here}\ref{WASM}.
\end{itemize}
\item \textbf{Swift}
\begin{enumerate}
    \item Official documentations:
    \href{https://www.swift.org/documentation/}{https://www.swift.org/documentation/}
\end{enumerate}
\item \textbf{Julia}

Easy to learn, easy to write, with high performance.

A nice language for \emph{scientific computing} and \emph{fast prototyping}, with native support for \emph{GPU programming and distributed programming}, as well as nice support for \emph{just-in-time (JIT)} compilation and \emph{gradual typing}.

Do not \textbf{overuse} it, e.g., I don't think it is suitable for large projects.

\begin{enumerate}
    \item Official documentation:
    \href{https://docs.julialang.org/en/v1/}{https://docs.julialang.org/en/v1/}
\end{enumerate}

\end{itemize}

\subsubsection{Theorem Prover List}
\begin{enumerate}
\item \textbf{Lean}

Mainly a theorem prover, also a programming language (though not so handy as languages designed to be a programming language).

\begin{enumerate}
    \item Lean Documentation:
    \href{https://leanprover.github.io/about/}{https://leanprover.github.io/about/}
    \item Recommended IDE: VSCode
    \item Tutorial of Lean3:\\
    \href{https://leanprover.github.io/theorem_proving_in_lean/}{https://leanprover.github.io/theorem_proving_in_lean/}
    \item Version management tool: \emph{elan}
    \item Recommended IDE: VSCode
\end{enumerate}

\item \textbf{Coq}

    Based on \emph{OCaml}.
    \begin{itemize}
        \item \href{https://coq.inria.fr/}{https://coq.inria.fr/}
    \end{itemize}

\item \textbf{Agda}

    Based on \emph{Haskell}.
    \begin{itemize}
        \item \href{https://wiki.portal.chalmers.se/agda/pmwiki.php}{https://wiki.portal.chalmers.se/agda/pmwiki.php}
    \end{itemize}
\end{enumerate}

\subsubsection{Other Languages}
\textbf{There is no clear boundary between PLs and libraries. Therefore, many libraries can be considered domain-specific languages (DSLs) and thus recommended below.}

There are also some languages worth noticing or even learning.
There belong to various programming paradigm, and have significant impact in the history of programming languages.

\subsubsection*{Array Programming}
\begin{itemize}
    \item APL, K
    \begin{itemize}
        \item Numpy can be seen as their modern descendent.
        Some DSLs derived from Numpy like PyTorch and JAX are also good choices.
    \end{itemize}
\end{itemize}

\subsubsection*{Logic Programming}
\begin{itemize}
    \item Prolog, Datalog, Epilog
\end{itemize}

\subsubsection*{Tensor Algebra}
\begin{itemize}
    \item Dense Tensor Algebra: Halide, TVM
    \item Sparse Tensor Algebra: TACO (\href{http://tensor-compiler.org/}{http://tensor-compiler.org/})
\end{itemize}

\subsubsection{Old Functional Languages}
\begin{itemize}
    \item Lisp dialects: Racket
\end{itemize}

\subsubsection*{Satifiability Modulo Theories (SMT) solver}
\begin{itemize}
    \item Z3, CVC5
\end{itemize}

\subsubsection*{Languages for Mathematicians}
\begin{itemize}
    \item Mathematica
\end{itemize}
    
\subsection{Functional Programming}
\begin{itemize}
    \item Books
    
    \begin{itemize}
        \item Recommended for green hands
        
        \emph{These books teach not only the syntax of FP, but (and more importantly) how to design software in the functional style, as well as the background and the origin of those functional features.}
        \begin{enumerate}
    \item Structure and Interpretation of Computer Programs (2nd Edition \cite{abelson1996structure}/JavaScript Edition \cite{abelson2022structure})
        \begin{itemize}
            \item The original version is based on \textbf{Scheme}, an Lisp dialect.
            However, Lisp and its dialects are obsolete now.
            But the book is still well worth recommending.
            \item The significance of the book goes well beyond teaching us functional programming.
        \end{itemize}
    \item Functional Programming in Scala
    \cite{chiusano2014functional}
            \begin{itemize}
                \item The 1st version is based on \emph{Scala 2}, while the second version is based on \emph{Scala 3}.
                Except for this, these two versions are basically the same.
            \end{itemize}
        \end{enumerate}
        \item Purely Functional Data Structures
        \cite{okasaki1999purely}
        \item Other books
            \begin{enumerate}
                \item Java 8 in Action: Lambdas, Streams, and Functional-style Programming (1st Edition) \cite{urma2014java}
                \item All books about \emph{Haskell} and \emph{OCaml}.
            \end{enumerate}
    \end{itemize}
    \item Suggested learning order in terms of languages
    \begin{enumerate}
        \item Start from \emph{OCaml/F\#}. This is the cleanest one. Personally, I think \emph{F\#} is better.
        \item Move on to \emph{Scala}. It has a lot more features and programming paradigms than \emph{OCaml/F\#}, thus harder to learn and prone to get confused. However, \textbf{trait} (\textbf{type class} in \emph{Haskell}) is very helpful for learning functional design, which is missing in \emph{OCaml} but present in \emph{F\#} (although it can be emulated by modules in \emph{OCaml}). Besides, since \emph{Scala} derives from \emph{Haskell}, it is helpful for you to learn the latter.
        \item At this point, you may try some languages with lots of functional features like \emph{Rust}.
        \item Then you can start challenge yourself with the legendary \emph{Haskell}. If your foundation of the previous stuffs is solid enough, it will not be so scary for you to learn this language. From the perspective of the programming language theory, it does possess some nice properties like \emph{termination} (if any evaluation order leads to termination, then natural order, adopted by \emph{Haskell}, will terminate).
        \end{enumerate}
\end{itemize}

\subsection{Programming Languages Theory}
It is not only about \emph{programming}, but also about \emph{verification}.
\begin{itemize}
    \item Courses
        \begin{itemize}
            \item Stanford CS 242 Programming Languages:
            \begin{itemize}
                \item Will Crichton:
                \href{https://stanford-cs242.github.io/f19/}{https://stanford-cs242.github.io/f19/} (more practical, more open-source materials like lecture notes and assignments)
                    \begin{itemize}
                        \item Languages used:
                        OCaml, WASM, Rust
                    \end{itemize}
                \item Alex Aiken:
                \href{https://web.stanford.edu/class/cs242/materials.html}{https://web.stanford.edu/class/cs242/materials.html} (more theoretical, better breadth and depth)
                    \begin{itemize}
                        \item Languages suggested being learned before this course:
                        OCaml, Haskell, Rust
                        \item Languages used:
                        \begin{enumerate}
                            \item C++, Java: mainstream OOP languages
                            \item OCaml, Haskell: statically typed functional languages; monad in Haskell
                            \item Python, JavaScript: mainstream dynamically typed languages
                            \item Rust: ownership (to implement type states)
                            \item Racket: call/cc to make use of continuations
                            \item Lean: theorem prover
                            \item NumPy: array programming with combinators
                        \end{enumerate}
                        \item Other languages useful for understanding the background:
                        \begin{enumerate}
                            \item Go: channel
                            \item TypeScript: gradual typing
                            \item Kotlin: coroutine
                            \item Scala: a complicated type system supporting most OOP and FP features
                        \end{enumerate}
                        \item Prerequisites:
                        \begin{itemize}
                            \item Compulsory:
                            \begin{enumerate}
                                \item Propositional Logic
                                \item Functional Programming
                            \end{enumerate}
                            \item Recommended:
                            \begin{enumerate}
                                \item Compilers
                                \item Programming Language Implementation
                            \end{enumerate}
                            \item Weakly Recommended:
                            \begin{enumerate}
                                \item Operating Systems
                                \item Computer Architecture
                                \item Theoretical Computer Science
                            \end{enumerate}
                            \item The background of this course is extremely profound, and thus the comprehensive knowledge of computer science, in particular, programming languages of different paradigms, does make a difference.
                        \end{itemize}

                    \end{itemize}
            \end{itemize}

            \item Stanford CS 151 Logic Programming:\\
            \href{http://logicprogramming.stanford.edu/stanford/lessons.php}{http://logicprogramming.stanford.edu/stanford/lessons.php}
        \end{itemize}
    \item Books
    \begin{enumerate}
        \item Foundations for Programming Languages
        \cite{mitchell1996foundations}
        \item Types and Programming Languages (1st Edition)
        \cite{pierce2002types}
        \begin{itemize}
            \item Based on \emph{OCaml}.
        \end{itemize}
        \item Advanced Topics in Types and Programming Languages (1st Edition) \cite{pierce2004advanced}
        \item Practical foundations for programming languages (2nd Edition)
        \cite{harper2016practical}
    \end{enumerate}
    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}

            \item One OOP language  (\emph{Java} is OK, but \emph{C++}/\emph{Python} is not enough), one FP language.
            Basic knowledge suffices.
            \begin{itemize}
                \item Personally, I recommend \emph{Scala/OCaml/F\#} (personally I think F\# is the best) + \emph{Rust}.
                They cover almost all the programming paradigms in modern and frequently used languages.
            \end{itemize}
        \end{enumerate}
        \item Recommended
        \begin{enumerate}
            \item Computer Architecture
            \item Compilers
            \item Operating systems
        \end{enumerate}
    \end{itemize}    
\end{itemize}
    \textbf{Suggestions}
        \begin{itemize}
            \item No need to master an entire PL in one shot; instead, study part of it when needed.
            \item PLs develop rapidly. To catch up with the latest development, refer to online documentations/tutorials/blogs besides books.
            \item Mastered at least one \emph{modern} language in each of the following paradigms:
            \begin{itemize}
                \item Procedural
                \item Object-Oriented
                \item Functional
            \end{itemize}
            Note that modern languages like \emph{Go}, \emph{Scala}, \emph{Kotlin} and \emph{Rust} can be greatly different than old ones like \emph{Java} and \emph{Python}.
            As a special case, although modern \emph{C++} (C++11 and later) is really modern, but there are inevitably a great number of legacies, so C++ can be considered as a mixture.
            \item PL can be viewed from at least three perspectives:
            \begin{itemize}
                \item Computer systems
                \item Software engineering
                \item Software theory
                \begin{itemize}
                    \item e.g., relationship between programming paradigms and Church-Turing thesis.
                \end{itemize}
            \end{itemize}
            Therefore, you can always find lots of cross-cutting issues in PL.
            \item A complete list of \emph{programming paradigms}:\\
            \href{https://en.wikipedia.org/wiki/Programming\_paradigm}{https://en.wikipedia.org/wiki/Programming\_paradigm}
            \item Pay attention to three kinds of \emph{safety}
            \begin{itemize}
                \item Type safety
                \item Memory safety
                \item Thread safety
            \end{itemize}
            \item Pay attention to the \emph{memory consistency model} (always called \emph{memory model} in this context) of each language, although this virtually has no impact on \emph{application-level programming}.
            \item \emph{Concrete examples} always help a lot for understanding \emph{abstract concepts}, and this is also one of the reasons why you should master several languages.
            \item Pay attention to the interoperation between a certain language with C/C++ (and languages on JVM with Java).
        \end{itemize}

\section{Parallel Computing}
\emph{Parallel computing} consists of three components:
\begin{itemize}
    \item Architecture (system)
    \item Programming (application)
    \item Algorithms (theory)
\end{itemize}
\emph{Parallel computing} is an natural extension to \emph{computer architecture}.\\
\textbf{Special Notes}
\begin{itemize}
    \item Do read \emph{Computer Architecture: A Quantitative Approach (CAAQA)} before diving into this, and revisit that masterpiece after having some hands-on experience of parallel computing!
    \item \emph{Parallel Computing} without \emph{Memory Optimization} is \textbf{ridiculous}!
    \item Do learn how to analyze performance bottleneck, which is key to the success of parallel programs.
    Knowledge like that of \emph{computer architecture} and \emph{operating systems} can be extremely helpful.
    \item \emph{Parallel computing} should include \emph{distributed computing}; however, the latter is not involved in this section.
\end{itemize}
\subsection{Platforms}
\begin{itemize}
    \item \textbf{CUDA} (Category: data parallel (logically), GPU)
    \begin{itemize}
        \item CUDA by Example (1st Edition) \cite{sanders2010cuda}
        \begin{itemize}
            \item A little obsolete, but the ideas are still well-presented.
            If your foundation is good enough, go to the following two documentations directly, and these two are highly recommended.
        \end{itemize}
        \item CUDA C++ Programming Guide:\\
        \href{https://docs.nvidia.com/cuda/cuda-c-programming-guide/}{https://docs.nvidia.com/cuda/cuda-c-programming-guide/}
        \item CUDA C++ Best Practices Guide:\\
        \href{https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/}{https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/}
        \item Thrust:
        \href{https://docs.nvidia.com/cuda/thrust/index.html}{https://docs.nvidia.com/cuda/thrust/index.html}
            \begin{itemize}
                \item STL in CUDA, providing some high-level abstractions.
            \end{itemize}
        \item All documentations can be found at:
        \href{https://docs.nvidia.com/cuda/}{https://docs.nvidia.com/cuda/}
    \end{itemize}
    CUDA is also fantastic for \emph{Asynchronous Programming} and \emph{Heterogeneous Programming}!
    You can also have a taste of \emph{Compute Hierarchy} with CUDA!
    \item Intel ISPC (Category: data parallel (logically), CPU)
    \begin{itemize}
        \item Intel ISPC User's Guide:
        \href{https://ispc.github.io/ispc.html}{https://ispc.github.io/ispc.html}
    \end{itemize}
    \item \textbf{CPU intrinsics} (Category: data parallel (logically), CPU)
    \begin{itemize}
        \item \textbf{x86 intrinsics} (Category: DLP, multimedia SIMD instruction set extensions)\\
        \href{https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html}{https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html}
        \item \textbf{ARM SVE2 intrinsics} (Category: DLP, vector architecture)\\
        \href{https://developer.arm.com/documentation/102340/0001/Program-with-SVE2}{https://developer.arm.com/documentation/102340/0001/Program-with-SVE2}
        \item \textbf{ARM Neon intrinsics} (Category: DLP, multimedia SIMD instruction set extensions)\\
        \href{https://developer.arm.com/documentation/102467/0100/Why-Neon-Intrinsics-}{https://developer.arm.com/documentation/102467/0100/Why-Neon-Intrinsics-}
    \end{itemize}
    \item \textbf{MPI} (Category: task parallel (logically), message passing)
    \begin{itemize}
        \item MPI Tutorial:
        \href{https://mpitutorial.com/tutorials/}{https://mpitutorial.com/tutorials/}
        \item YouTube video
        \begin{itemize}
            \item MPI Basics:
            \href{https://www.youtube.com/watch?v=c0C9mQaxsD4}{https://www.youtube.com/watch?v=c0C9mQaxsD4}
            \item MPI Advanced:
            \href{https://www.youtube.com/watch?v=q9OfXis50Rg}{https://www.youtube.com/watch?v=q9OfXis50Rg}
        \end{itemize}
    \end{itemize}
    \item \textbf{OpenMP} (Catrgory: data parallel (logically), shared memory)
    \begin{itemize}
        \item Tim Mattson’s (Intel) “Introduction to OpenMP” (2013) on YouTube
        \begin{itemize}
            \item Video:\\
            \href{https://www.youtube.com/playlist?list=PLLX-Q6B8xqZ8n8bwjGdzBJ25X2utwnoEG}{https://www.youtube.com/playlist?list=PLLX-Q6B8xqZ8n8bwjGdzBJ25X2utwnoEG}
            \item Slides:\\
            \href{https://www.openmp.org/wp-content/uploads/Intro\_To\_OpenMP\_Mattson.pdf}{https://www.openmp.org/wp-content/uploads/Intro\_To\_OpenMP\_Mattson.pdf}
        \end{itemize}
    \end{itemize}
    For those familiar with \emph{pthread}, it is quite easy to learn \textbf{OpenMP}.
    \item High-level DSLs
    \begin{enumerate}
        \item PyTorch
        \begin{itemize}
            \item PyTorch 2.0 has been released!
            \item The official site (\href{https://pytorch.org/}{https://pytorch.org/}) provides enough learning resources of high quality
        \end{itemize}
        \item JAX:
        \href{https://jax.readthedocs.io/en/latest/}{https://jax.readthedocs.io/en/latest/}
    \end{enumerate}
\end{itemize}
\subsection{Categories}
The essence of \emph{parallel computing} is \emph{the lack of dependencies}.
\begin{itemize}
    \item ILP (Instruction-Level Parallelism)\\
    Mathematical model of ILP -- DAG (Directed Acyclic Graph):
    \begin{itemize}
        \item Node: a stage of a instruction.
        \item Edge: dependency (data dependency, control dependency, name dependency) between a pair of nodes.
    \end{itemize}
    Goal:
    eliminate dependencies (edges), and exploit the lack of dependencies between nodes.
    \item DLP (Data-Level Parallelism)\\
        The essence of DLP programming: \emph{Vectorization}.
        \begin{itemize}
            \item To get some hands-on experiences with this, you may start with \emph{PyTorch}, since this relieves you from some low-level details like remaining elements and memory hierarchy.
            \begin{itemize}
                \item Official tutorial: \href{https://pytorch.org/tutorials/}{https://pytorch.org/tutorials/}
                \item Also, \textbf{PyTorch} is a convenient tool to exploit GPU for parallel computing.
            \end{itemize}
        \end{itemize}
        
    \item TLP (Thread-Level Parallelism)\\
    The essence of TLP programming: \textbf{async} (concurrent control flow), \textbf{await} (synchronization).
    \begin{itemize}
        \item Concurrency mechanisms
        \begin{enumerate}
            \item Thread: nearly all mainstrean languages support this, e.g., C++ std::thread/jthread, Java, pthread
            \item Future/Promise: most of mainstrean languages support this,  e.g., Scala, C++, Java
            \item Stackful Coroutine: Go, Haskell
            \item Stackless Coroutine: Kotlin, Rust (async/await, Tokio), F\# (async/task), Haskell
        \end{enumerate}
        \textbf{Aside}:
        \begin{enumerate}
                \item Here is a good summary of \emph{Asynchronous programming techniques} provided in the tutorial of \emph{Kotlin}:
            \href{https://kotlinlang.org/docs/async-programming.html}{https://kotlinlang.org/docs/async-programming.html}
            \item The essence of \emph{Asynchronous Programming} is \emph{async/await}, as well as \emph{suspension points}.
            \begin{itemize}
                \item For \emph{Threads} and \emph{Stackful Coroutines}, every point is a suspension point, while for \emph{Stackless Coroutines}, only a fraction of points can be suspension points and they are declared explicitly.
            \end{itemize}
            \item For implementations, figure out what is ``\textbf{continuation}" and how it varies in \emph{Processes}, \emph{Threads}, \emph{Stackful Coroutines}, and \emph{Stackless Coroutines}.
            Also think about the relation between \emph{continuation} and \emph{suspension points}.
        \end{enumerate}

        \item Synchronization mechanisms
        \begin{itemize}
            \item Shared memory
            \begin{enumerate}
                \item Mutex, Condition Variable: most languages.
                \item Monitor: Java.
                For C++, this can be readily emulated by \emph{RAII}.
                \item Atomic variables/operations: most languages.
                \item Barrier: most languages, especially popular in data parallel programming like CUDA.
                \item Read Write Lock: most languages.
                \item Software Transactional Memory: Haskell.
            \end{enumerate}
            Many widely used mechanisms are not listed here.
            \item Message passing
            \begin{enumerate}
                \item Channel + Select: Go, Kotlin.
                \item Actor Model:
                    \begin{itemize}
                        \item Akka (with Java/Scala interface):\\ \href{https://doc.akka.io/docs/akka/current/typed/guide/introduction.html}{https://doc.akka.io/docs/akka/current/typed/guide/introduction.html}
                        \item Kotlin:\\
                        \href{https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#actors}{https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html\#actors}
                        \item F\# MailboxProcessor:\\
                        \href{https://fsharpforfunandprofit.com/posts/concurrency-actor-model/}{https://fsharpforfunandprofit.com/posts/concurrency-actor-model/}
                    \end{itemize}
            \end{enumerate}
            \item High-level encapsulations
            \begin{enumerate}
                \item Thread-safe collections
                    \begin{itemize}
                    \item Java: java.util.concurrent:\\
                    \href{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/package-summary.html}{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util\\/concurrent/package-summary.html}
                    \end{itemize}
            \end{enumerate}
        \end{itemize}
        \item Aside -- comparison among \emph{concurrency}, \emph{parallelism}, \emph{asynchrony}:
        \begin{enumerate}
            \item Concurrency: when multiple computations execute in overlapping time periods.
            \item Parallelism: when multiple computations or several parts of a single computation run at exactly the same time.
            \item Asynchrony: when one or more computations can execute separately from the main program flow.
        \end{enumerate}
        (Source: \href{https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/async}{https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/async})
    \end{itemize}
\end{itemize}
\subsection{Principles of Parallel Computing}
\begin{itemize}
    \item Stanford CS 149 Parallel Computing:
    \href{https://gfxcourses.stanford.edu/cs149/fall21/}{https://gfxcourses.stanford.edu/cs149/fall21/}
    \begin{itemize}
        \item Programming languages and platforms used:
        \begin{enumerate}
            \item C++ and std::thread
            \item ISPC
            \item CUDA
            \item OpenMP
            \item AVX intrinsics
        \end{enumerate}
    \end{itemize}
    \item Stanford CS315B Parallel Programming:\\
    \href{https://web.stanford.edu/class/cs315b/}{https://web.stanford.edu/class/cs315b/}
    \item Stanford CME 323 Distributed Algorithms and Optimization:\\
    \href{https://stanford.edu/~rezab/classes/cme323/S20/}{https://stanford.edu/~rezab/classes/cme323/S20/}
\end{itemize}
\textbf{Prerequisites}
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
        \item Computer Architecture
    \end{enumerate}
        \item Recommended:
        \begin{enumerate}
            \item \textbf{Functional Programming} (strongly recommended)
            \item Operating Systems
            \item Compilers
        \end{enumerate}
    \end{itemize}

\subsection{Memory Model}
It is also called ``Memory Consistency Model" or ``Memory Order" sometimes.

In my opinion, it is the \emph{trickiest} part in \emph{concurrent programming}.

This is a cross-cutting issue, involving the following fields:
\begin{enumerate}
    \item computer architecture: memory consistency;
    \item concurrent programming: lock-free programming;
    \item compilers: reordering (including code scheduling, speculation, partial redundancy elimination, common subexpression elimination, copy propagation, redundant read/write elimination, etc), register allocation.
\end{enumerate}
This issue occurs in the following scenarios:
\begin{enumerate}
    \item lock-free programming,
    \item compiler development,
    \item development of concurrency
    related libraries
    \item OS development.
\end{enumerate}

As an example, for C++, the following things are involved:
\begin{enumerate}
    \item memory order (served as argument to the functions/methods of the following),
    \item atomic,
    \item atomic thread fence,
    \item atomic signal fence (compiler fence).
\end{enumerate}

Memory models of mainstream PLs can be divided into several categories:
\begin{enumerate}
    \item C++, Rust, Go;
    \item Java;
    \item OCaml.
\end{enumerate}
Concrete descriptions can be found in their respective official documentation.
They are worth reading, but too inaccessible for green hands.
There are some more newbie-friendly resources:
\begin{enumerate}
    \item Preshing's blog posts (for C++):\\
    \href{https://preshing.com/20120913/acquire-and-release-semantics/}{https://preshing.com/20120913/acquire-and-release-semantics/}
    \begin{itemize}
        \item There are many related articles in his blogs and I highly recommend them!
    \end{itemize}
    \item Rust Atomics and Locks:
    \href{https://marabos.nl/atomics/preface.html}{https://marabos.nl/atomics/preface.html}
    \begin{itemize}
        \item Chapter 2, 3, 7.
    \end{itemize}
    \item The Java Memory Model:\\
    \href{http://www.cs.umd.edu/~pugh/java/memoryModel/}{http://www.cs.umd.edu/~pugh/java/memoryModel/}
\end{enumerate}

There are also some paper worth reading:
\begin{enumerate}
    \item Boehm's papers for the C++ memory model:
    \begin{enumerate}
        \item Threads Cannot be Implemented as a Library:\\
        \href{https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf}{https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf}
        \item  Foundations of the C++ Concurrency Memory Model:\\
        \href{https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf}{https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf}
    \end{enumerate}
    \item The Java Memory Model:\\
    \href{https://rsim.cs.uiuc.edu/Pubs/popl05.pdf}{https://rsim.cs.uiuc.edu/Pubs/popl05.pdf}
    \item Bounding Data Races in Space and Time (for OCaml memory model):\\
    \href{https://dl.acm.org/doi/pdf/10.1145/3192366.3192421}{https://dl.acm.org/doi/pdf/10.1145/3192366.3192421}
\end{enumerate}

Tips:
\begin{enumerate}
    \item Compiler Explorer (\href{https://godbolt.org/}{https://godbolt.org/}) will be your good friend.
    \item Try different PLs and ISAs!
    \item Sometimes you need to refer to ISA specifications.
\end{enumerate}

\section{Asynchronous Programming}
\textbf{Notes}

\noindent
While parallel computing tackles the performance engineering of compute-bound programs, asynchronous programming deals with the performance engineering of I/O-bound programs, and the latter is generally harder than the former.

\subsection{Async Support in Programming Languages}

\subsubsection{Async Framework}
They come in two flavors:
\begin{enumerate}
    \item \textbf{Stackful Coroutines}

    They are also called user threads or green threads.
    Their programming model is the same as kernel threads.
    
    List of famous PL that supports this:
    \begin{enumerate}
        \item Java 21 virtual threads.
        \item Go goroutines.
    \end{enumerate}
    \item \textbf{Stackless Coroutines}
    
    This is sometimes just called asynchronous programming in the manual/tutorials of PLs.

    Typically this kind of programming paradigm involves two keywords:
    async, await

    List of famous PL that supports this:
    \begin{enumerate}
        \item Rust asynchronous programming.
        \item Kotlin coroutines.
        \item C\#/F\# asynchronous programming.
        \item Python asyncio
        \item JavaScript
        \item Swift concurrency.
        \item C++ 20 coroutines (not mature yet).
    \end{enumerate}
\end{enumerate}
\subsubsection{Support for Asynchronous Operations}

Support for asynchronous operations (e.g., asynchronous I/O operations, asynchronous synchronization mechanisms) is also essential.
I consider this as part of the ecosystem of asynchronous programming of a PL.

C\#/F\#, Rust, JavaScript do well here, but Kotlin (due to the lack of asynchrony of JVM), Swift currently don't.
Worse still, C++ doesn't even has a first-party networking library...

\subsection{Async Support in System Calls Level}

\subsubsection{Non-blocking Syscalls}
\begin{itemize}
    \item Sockets have nice support for this, while regular files generally don't.
    \item Linux man page is a good resource.
\end{itemize}
\subsubsection{I/O Multiplexing}
\begin{enumerate}
    \item Reactive: select (deprecated), poll (deprecated), epoll
    \begin{itemize}
        \item epoll has two modes, level-triggered and edge-triggered; both are worth learning;
        \item these are mainly for network programming, and works poorly for file I/O;
        \item Linux man page is a good resource for these syscalls.
    \end{itemize}
    \item Proactive: io\_uring
    \begin{itemize}
        \item Lord of io\_uring:
        \href{https://unixism.net/loti/}{https://unixism.net/loti/}
        \item Efficient IO with io\_uring:
        \href{https://kernel.dk/io_uring.pdf}{https://kernel.dk/io\_uring.pdf}
        \item Though powerful (and arguably the future of Linux), io\_uring is still in an early stage -- incomplete and sometimes poor docs, dramatic improvement over versions, lots of vulnerabilities.
        \item Manually installed liburing may not work with your OS.
        \item io\_uring provides true asynchrony of file I/O (aio is implemented by a thread pool).
        \item Personally, I think io\_uring has profound implications.
        Asking for services from OS no longer requires syscalls.
        \item Two key idea of io\_uring:
        Reduce kernel crossing and memory copy.
    \end{itemize}
\end{enumerate}
\subsection{Kernel Bypassing Techniques}
These require support from hardware.
\begin{enumerate}
    \item RDMA
    \item DPDK
    \item SPDK
\end{enumerate}
I don't know much about these.
Mark them here and hopefully one day I will come back.


\section{Databases (DB)}
\textbf{Special Notes}
\begin{itemize}
    \item Think about the relationship (cooperation and conflicts) between DB and OS.
    Also, when facing the same issues (there are lots of them) like concurrency control, how do they handle them respectively?
    \item \emph{Parallel and distributed databases} and \emph{NoSQL} are the hotspots nowadays.
    Do place emphasis on them!
    \item View DB from a full-stack perspective, that is, from systems, to applications, to theory (relation algebra).
    Lots of knowledge you have learned elsewhere plays an important role here.
    Also, you can find plenty of cross-cutting issues here.
    \item Pay attention to the relationship between DB and big data/data mining.
\end{itemize}

\begin{enumerate}
    \item Books
    \begin{enumerate}
    \item Databases System Concepts (7th Edition) \cite{silberschatz2002database}
    \begin{itemize}
        \item Partition:
        \begin{itemize}
            \item Application: Chapter 2-11, 25, 26, 28-32
            \item Systems: Chapter 12-24, 32
            \item Theory: Chapter 2, 27
        \end{itemize}
        As a beginner, you may read chapter 1-7, 12-19 first.        
        \item For Chapter 20-23, basic knowledge of \emph{distributed systems} can be quite helpful.
        See ``Prerequisites" for more advice.
        \item Reflect on Chapter 10-11 after gaining some experiences on big data/cloud computing (e.g., programming with Spark).
        \item Although Chapter 3-5 does teach a lot of SQL and these are really helpful, you should refer to the following manuals if you want to learing more specifications, especially those specific to a certain implementation of SQL.
        \item CMU 15-445 and Stanford CS 145, 245 are mostly covered by this book.
        \item Recommended online chapters
        \begin{enumerate}
            \item Chapter 27: Formal-Relational Query Languages.
            Coverage:
            \begin{enumerate}
                \item The tuple relational calculus
                \item The domain relational calculus
                \item \emph{Datalog} (a nonprocedural query language based on the \emph{logic-programming} language \emph{Prolog})
            \end{enumerate}
            \item Chapter 32: PostgreSQL.
            A good case study.
        \end{enumerate}
    \end{itemize}
    \item Supplementary
        \begin{enumerate}
            \item Databases Systems: The Complete Book
            \cite{garcia2008database}
        \end{enumerate}
    \end{enumerate}
    \item Courses
    \begin{enumerate}
        \item DB applications
        \begin{itemize}
            \item Stanford CS 145 Data Management and Data Systems:\\
            \href{https://cs145-fa20.github.io/}{https://cs145-fa20.github.io/}
        \end{itemize}
        \item DB systems
        \begin{itemize}
            \item CMU 15-445/645 Intro to Databases Systems:\\
            \href{https://15445.courses.cs.cmu.edu/fall2019/schedule.html}{https://15445.courses.cs.cmu.edu/fall2019/schedule.html}
            \item Stanford CS 245 Principles of Data-Intensive Systems:\\
            \href{https://web.stanford.edu/class/cs245/}{https://web.stanford.edu/class/cs245/}
        \end{itemize}
            \item Advanced DB systems
            \begin{itemize}
                \item CMU 15-721 Advanced Databases Systems:\\
                \href{https://15721.courses.cs.cmu.edu/spring2020/schedule.html}{https://15721.courses.cs.cmu.edu/spring2020/schedule.html}        
            \end{itemize}
    \end{enumerate}

    \item Query languages and platforms
    \begin{itemize}
        \item SQL
        \begin{itemize}
            \item PostgreSQL
            \begin{enumerate}
                \item Databases System Concepts chapter 32:\\
                \href{https://db-book.com/online-chapters-dir/32.pdf}{https://db-book.com/online-chapters-dir/32.pdf}
                \item Tutorial:
                \href{https://www.postgresqltutorial.com/}{https://www.postgresqltutorial.com/}
                \item Documentation \& Manuals:
                \href{https://www.postgresql.org/docs/}{https://www.postgresql.org/docs/}
            \end{enumerate}     
            \item MySQL
            \begin{enumerate}
                \item Tutorial:
                \href{https://www.mysqltutorial.org/}{https://www.mysqltutorial.org/}
                \item Reference manual:
                \href{https://dev.mysql.com/doc/refman/8.0/en/}{https://dev.mysql.com/doc/refman/8.0/en/}
            \end{enumerate}
            \item Which one should I choose?
            \begin{enumerate}
                \item They are two most popular open source databases.
                \item Generally speaking, MySQL is still more popular for historic reasons, while PostgreSQL is more advanced and far more elegant.
                \item \emph{MySQL}'s syntax is relatively weird and the error and its error reporting is relatively vague and even misleading.
            \end{enumerate}
            \item Tips of using specific databases:\\
            \href{https://db-book.com/university-lab-dir/db-tips.html}{https://db-book.com/university-lab-dir/db-tips.html}
        \end{itemize}
        \item NoSQL
        \begin{itemize}
            \item MongoDB
            \begin{enumerate}
                \item Get Started:
                \href{https://www.mongodb.com/docs/guides/}{https://www.mongodb.com/docs/guides/}
                \item Documentations:
                \href{https://www.mongodb.com/docs/}{https://www.mongodb.com/docs/}
            \end{enumerate}
        \end{itemize}
        \item Redis
        \begin{enumerate}
            \item \href{https://redis.io/}{https://redis.io/}
        \end{enumerate}
        \item Spark
        \begin{itemize}
            \item Quick Start:
            \href{https://spark.apache.org/docs/latest/quick-start.html}{https://spark.apache.org/docs/latest/quick-start.html}
        \end{itemize}
        \item .NET LINQ
            \begin{enumerate}
                \item \href{https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/}{https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/}
            \end{enumerate}
        \item DB-Engines Ranking:
            \href{https://db-engines.com/en/ranking}{https://db-engines.com/en/ranking}
            \begin{itemize}
                \item Popular databases engines and lots of relevant information can be found here.
            \end{itemize}        
        \item Advice:
        \begin{enumerate}
            \item When studying query languages, reason about \emph{declarative programming} (e.g., \emph{SQL}) and \emph{logic programming} (e.g., \emph{Datalog}).
            (Aside: \emph{logic programming} is a subset of \emph{declarative programming}.)
        \end{enumerate}
    \end{itemize}

    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
            \item Data structures and algorithms: those operating data on secondary storage are particularly important
            \item Operating systems
        \end{enumerate}
        \item Recommended:
        \begin{enumerate}
            \item Computer architecture
            \begin{itemize}
                \item Lots of similar ideas in \emph{databases} can be found in \emph{computer architecture})
            \end{itemize}
            \item Computer networks
            \begin{itemize}
                \item required for learning \emph{parallel and distributed databases})
            \end{itemize}
            \item Programming languages
            \begin{itemize}
                \item Query languages help deepening our understanding of differences among programming paradigms (e.g., \emph{imperative} vs \emph{declarative}), as well as some feasible but rarely used programming paradigms (e.g., \emph{logic programming}).
            \end{itemize}
        \end{enumerate}
        \item A few words about \emph{distributed systems}
        \begin{itemize}
            \item It is quite hard to determine which one of the following should be learned first: \emph{parallel and distributed databases} and \emph{distributed systems}.
            My personal feeling is, study of these two fields can be interleaved, since you often need knowledge of the other field when studying either one field.
            As a always reasonable method, study them multiple times so that you will not miss important prerequisite knowledge, if the optimal order of learning is hard to figure out.
        \end{itemize}
        \item PL
        \begin{itemize}
            \item Java: JDBC.
        \end{itemize}
    \end{itemize}
\end{enumerate}

\section{Distributed Computing/Distributed Systems}
\begin{enumerate}
    \item MIT 6.824 Distributed Systems:
    \href{https://pdos.csail.mit.edu/6.824/schedule.html}{https://pdos.csail.mit.edu/6.824/schedule.html}
    \item Supplementary
    \begin{enumerate}
        \item Princeton COS 418 Distributed Systems:\\
        \href{https://www.cs.princeton.edu/courses/archive/fall19/cos418/}{https://www.cs.princeton.edu/courses/archive/fall19/cos418/}
        \item Stanford CS 244B Distributed Systems:
        \href{https://www.scs.stanford.edu/22sp-cs244b/}{https://www.scs.stanford.edu/22sp-cs244b/}
        \item Stanford CS 251 Cryptocurrencies and Blockchain Technologies:\\
        \href{https://cs251.stanford.edu/}{https://cs251.stanford.edu/}
    \end{enumerate}
    
    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
        \item Operating Systems
        \item Computer Networks
        \item Databases        
        \end{enumerate}
        \item Recommended:
        \begin{enumerate}
        \item Computer Architecture
        \item Programming Languages
        \begin{itemize}
            \item A little experiences with \emph{functional programming} are quite helpful for learning \emph{distributed computing}.
        \end{itemize}
        \end{enumerate} 
    \end{itemize}
\end{enumerate}

\section{Cloud Computing}
\begin{enumerate}
    \item CMU 15-719 Advanced Cloud Computing:\\
    \href{https://www.cs.cmu.edu/~15719/old/spring2019/syllabus.html}{https://www.cs.cmu.edu/~15719/old/spring2019/syllabus.html}
    \item Stanford CS349D Cloud Computing Technology:\\
    \href{http://web.stanford.edu/class/cs349d/}{http://web.stanford.edu/class/cs349d/}
    \item Containers and container management systems
    \begin{enumerate}
        \item Docker
        \item Kubernetes (K8s)
    \end{enumerate}
    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
            \item Operating Systems
            \item Computer Networks
            \item Distributed Systems
            \item Databases
        \end{enumerate}
    \end{itemize}
    \item \textbf{Suggestions}
    \begin{enumerate}
        \item There are plenty of \emph{cross-cutting issues}.
        Make sure the prerequisites are met before moving on.
        \item When reading cutting-edge papers concerning \emph{OS}, \emph{computer network} or \emph{computer architecture}, you may encounter issues of \emph{cloud computing}.
        At that moment, you had better have some basic knowledge about it before reading those papers.
    \end{enumerate}
\end{enumerate}

\section{Graphics}
\begin{enumerate}
    \item Stanford CS 248A
    Computer Graphics:
Rendering, Geometry, and Image Manipulation\\
\href{https://cs248a.stanford.edu}{https://cs248a.stanford.edu}
    \item Stanford CS 348K
    Visual Computing Systems\\
    \href{https://cs348k.stanford.edu}{https://cs348k.stanford.edu}
    \item Only systems-related courses are listed.
    For other graphics-related courses, please search CS *48 (* stands for one digit) with any suffix at \\
    \href{https://explorecourses.stanford.edu/}{https://explorecourses.stanford.edu/}
\end{enumerate}

\section{Big Data}
\begin{enumerate}
    \item Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems (1st Edition) \cite{kleppmann2017designing}
    \item Prerequisites:
    \begin{itemize}
        \item Compulsory
        \begin{enumerate}
            \item Databases
            \item Distributed systems
        \end{enumerate}
    \end{itemize}
\end{enumerate}

\section{Software Engineering}
\begin{itemize}
    \item The Mythical Man-Month: Essays on Software Engineering (Anniversary Edition) \cite{brooks1995mythical}
    \item Design Patterns: Elements of Reusable Object-Oriented Software
    \cite{gamma1995design}
    \begin{itemize}
        \item The authors are often referred to as the \textbf{Gang of Four (GoF)}.
    \end{itemize}
    \item A Philosophy of Software Design (2nd Edition) \cite{ousterhout2018philosophy}
    \item Write Great Code, Volume 3: Engineering Software
    \cite{hyde2020writegreatcode}
    \item Materials discussing \emph{best practice} are also valuable, which can be found at the \textbf{PL} section, as well as the \textbf{CUDA} subsection.
\end{itemize}

\section{Program Analysis}
Can be regarded as part of \emph{compilers techniques} in a broad sense.
\begin{enumerate}
    \item Software Foundations:
        \href{https://softwarefoundations.cis.upenn.edu/}{https://softwarefoundations.cis.upenn.edu/}
        \begin{itemize}
            \item It consists of 6 volumes.
            \item Volume 1 also teaches \emph{Coq}.
        \end{itemize}
    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
            \item Compilers
            \item Programming languages
        \end{enumerate}
    \end{itemize}
\end{enumerate}

\section{Computer Security \& Cryptography}
Security issues are everywhere.
New security issues and arise with new computer technologies invented.

\emph{Threat models} are likely to differ with field varying (e.g., hardware vs OS), leading to distinct technologies.

Basic knowledge of \emph{memory safety} of programming languages helps.

\begin{enumerate}
    \item Textbooks
    \begin{enumerate}
        \item A Graduate Course in
Applied Cryptography\\
        \href{https://toc.cryptobook.us/}{https://toc.cryptobook.us/}
    \end{enumerate}
    \item Courses
    \begin{enumerate}
        \item UC Berkeley CS 161 Computer Security:
        \href{https://sp22.cs161.org/}{https://sp22.cs161.org/}
        \item Stanford CS 155 Computer and Network Security:
        \href{https://cs155.stanford.edu/}{https://cs155.stanford.edu/}
        \item Stanford CS 253 Web Security:
        \href{https://web.stanford.edu/class/cs253/}{https://web.stanford.edu/class/cs253/}
        \item Stanford CS 255 Introduction to Cryptography:
        \href{https://crypto.stanford.edu/~dabo/cs255/}{https://crypto.stanford.edu/~dabo/cs255/}
        \item Stanford CS 350 Secure Compilation:\\
        \href{https://theory.stanford.edu/~mp/mp/CS350-2019.html}{https://theory.stanford.edu/~mp/mp/CS350-2019.html}
        \item Stanford CS 355 Advanced Topics in Cryptography:\\
        \href{https://cs355.stanford.edu/}{https://cs355.stanford.edu/}
        \item Stanford CS 356 Topics in Computer and Network Security:
        \href{https://cs356.stanford.edu/}{https://cs356.stanford.edu/}    \end{enumerate}

    \item Meltdown and Spectre:
    \href{https://meltdownattack.com/}{https://meltdownattack.com/}
    \item Prerequisites:
    \begin{itemize}
        \item Compulsory:
        \begin{enumerate}
            \item Operating systems
            \item Computer networks
            \item (Basic) Probability (for cryptography)
            \item (Basic) Number Theory (for cryptography)
        \end{enumerate}
        \item Recommended:
        \begin{enumerate}
            \item Computer architecture
            \item Programming languages
            \item Compilers
            \item Databases
        \end{enumerate}
        Indeed, you can learn a lot about \emph{computer security} in all of these fields.
        Pay special attention to \emph{security} issues when diving in these fields.
    \end{itemize}
\end{enumerate}

\section{Web}
These are mostly \emph{application} stuff.
But these contents are frequently involved in the modern computer world, therefore, I add this section in case we may need them sometimes.
\begin{enumerate}
    \item Stanford CS 142 Web Applications:\\
    \href{https://web.stanford.edu/class/cs142/index.html}{https://web.stanford.edu/class/cs142/index.html}
    \item Stanford CS 192X Web Programming Fundamentals:\\
    \href{https://web.stanford.edu/class/archive/cs/cs193x/cs193x.1176/lectures/}{https://web.stanford.edu/class/archive/cs/cs193x/cs193x.1176/lectures/}
    \item Find more tutorials and references at \emph{W3Schools}:
    \href{https://www.w3schools.com/}{https://www.w3schools.com/}
    \item Prerequisites:
    \begin{itemize}
        \item Recommended:
        \begin{enumerate}
            \item Operating systems
            \item Computer networks
            \item Databases
        \end{enumerate}
    \end{itemize}
\end{enumerate}

\section{Instruction Set Architecture (ISA)}
All of the following ISA can be learned by CSAPP or ``Computer Organization and Design: The Hardware/Software Interface".
However, the following resources help you go further.
\begin{itemize}
    \item \textbf{x86}
    \begin{itemize}
        \item Intel® 64 and IA-32 Architectures Software Developer Manuals:\\
        \href{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}
        \item AMD Developer Guides, Manuals \& ISA Documents:\\
        \href{https://developer.amd.com/resources/developer-guides-manuals/}{https://developer.amd.com/resources/developer-guides-manuals/}
    \end{itemize}
    Master both the ``Intel" format and the ``AT\&T" format.
    \item \textbf{RISC-V}
    \begin{itemize}
        \item RISC-V Specifications:
        \href{https://riscv.org/technical/specifications/}{https://riscv.org/technical/specifications/}
        \begin{itemize}
            \item Wonderful books on computer architecture!
        \end{itemize}
    \end{itemize}
    \item \textbf{ARM}
    \begin{itemize}
        \item ARM® CPU Architecture Key Documents:\\
        \href{https://developer.arm.com/architectures/cpu-architecture}{https://developer.arm.com/architectures/cpu-architecture}
        \item Arm® Architecture Reference Manual Supplement Armv9, for Armv9-A architecture profile:
        \href{https://developer.arm.com/documentation/ddi0608/latest}{https://developer.arm.com/documentation/ddi0608/latest}
    \end{itemize}
    \item \textbf{PTX}
    \begin{itemize}
        \item PTX ISA :: CUDA Toolkit Documentation:\\
        \href{https://docs.nvidia.com/cuda/parallel-thread-execution/}{https://docs.nvidia.com/cuda/parallel-thread-execution/}
    \end{itemize}
    \item \textbf{Java Bytecode}
    \begin{itemize}
        \item Java Language and Virtual Machine Specifications:\\
    \href{https://docs.oracle.com/javase/specs/}{https://docs.oracle.com/javase/specs/}
    \begin{itemize}
        \item CLick "The Java Virtual Machine Specification"
    \end{itemize}
    \item List of Java bytecode instructions (Wikipedia):\\
    \href{https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions}{https://en.wikipedia.org/wiki/List\_of\_Java\_bytecode\_instructions}
    \end{itemize}
    \item \textbf{WebAssembly}\label{WASM}\\
    Strictly speaking, it is not an ISA, but they share a lot in common, and it is well worth studying, so I put it here.
    \begin{itemize}
        \item Official website:
        \href{https://webassembly.org/}{https://webassembly.org/}
        \item Specification:
        \href{https://webassembly.github.io/spec/core/index.html}{https://webassembly.github.io/spec/core/index.html}
        \item Bringing the Web up to Speed with WebAssembly:\\
        \href{https://people.mpi-sws.org/~rossberg/papers/Haas,\%20Rossberg,\%20Schuff,\%20Titzer,\%20Gohman,\%20Wagner,\%20Zakai,\%20Bastien,\%20Holman\%20-\%20Bringing\%20the\%20Web\%20up\%20to\%20Speed\%20with\%20WebAssembly.pdf}{https://people.mpi-sws.org/~rossberg/papers/Haas,\%20Rossberg,\%20Schuff,\\
        \%20Titzer,\%20Gohman,\%20Wagner,\%20Zakai,\%20Bastien,\%20Holman\%20-\\
        \%20Bringing\%20the\%20Web\%20up\%20to\%20Speed\%20with\%20WebAssembly.pdf}
    \end{itemize}
\end{itemize}


\section{Linking and Loading}
\begin{enumerate}
    \item 
    \begin{CJK}{UTF8}{gbsn}
    程序员的自我修养: 链接, 装载与库 \cite{selfcultivation}
    \end{CJK}
    \item Linkers and Loaders (1st Edition) \cite{levine264linkers}
    \item \textbf{Suggestions}
    \begin{enumerate}
        \item Do not just \emph{read books} or \emph{play with GCC/Clang}.
        Do both together.
        \item The first book plays a primary role, while the second is supplementary (however, I still recommend you read it).
        \item These two books are relatively \textbf{obsolete} (sorry I did not find any relevant modern book).
        Besides, there are lots of academic errors in the first book.
        \item These two books cover lots of knowledge.
        Pick the chapters you need.
        There is no need to read every chapter.
    \end{enumerate}
\end{enumerate}

\section{Tools}
\begin{enumerate}
    \item Git
    \begin{itemize}
        \item Git Magic:
        \href{http://www-cs-students.stanford.edu/~blynn/gitmagic/book.pdf}{http://www-cs-students.stanford.edu/~blynn/gitmagic/book.pdf}
        \item GitHub Get started:
        \href{https://docs.github.com/en/get-started/quickstart/hello-world}{https://docs.github.com/en/get-started/quickstart/hello-world}
        \item GitHub Documentations:
        \href{https://docs.github.com}{https://docs.github.com}
        \item Official documentations:
        \href{https://git-scm.com/doc}{https://git-scm.com/doc}
        \item \emph{GitHub Desktop} is recommended.
    \end{itemize}
    \item UNIX Makefile
    \begin{itemize}
        \item Makefile Tutorial By Example:
        \href{https://makefiletutorial.com/}{https://makefiletutorial.com/}
    \end{itemize}
    \item Docker
    \begin{itemize}
        \item Official tutorials and documentations:
        \href{https://docs.docker.com/}{https://docs.docker.com/}
    \end{itemize}
    \item Shell Script
    \begin{itemize}
        \item Shell Scripting Tutorial:
        \href{https://www.shellscript.sh/}{https://www.shellscript.sh/}
        \item The following two tutorials are basically the same and are written by the same author, with the former being more newbie-friendly:
        \begin{itemize}
            \item Bash Scripting Tutorial for Beginners:\\ \href{https://linuxconfig.org/bash-scripting-tutorial-for-beginners}{https://linuxconfig.org/bash-scripting-tutorial-for-beginners}
            \item Bash Scripting Tutorial: \href{https://linuxconfig.org/bash-scripting-tutorial}{https://linuxconfig.org/bash-scripting-tutorial}
        \end{itemize}
        \item GNU Bash manual: \href{https://www.gnu.org/software/bash/manual/}{https://www.gnu.org/software/bash/manual/}
    \end{itemize}
\end{enumerate}

\section{Coding Style}
\begin{itemize}
    \item Google Style Guides:
    \href{https://google.github.io/styleguide/}{https://google.github.io/styleguide/}
    \item Clang-Format Style Options:
    \href{https://clang.llvm.org/docs/ClangFormatStyleOptions.html}{https://clang.llvm.org/docs/ClangFormatStyleOptions.html}
    \begin{itemize}
        \item \emph{VS Code} can automatically format your code with a ``.clang-format" file without installing anything!
    \end{itemize}
\end{itemize}

\section{Miscellany}
\begin{enumerate}
    \item Intel® Product Specifications:
    \href{https://ark.intel.com}{https://ark.intel.com}
    \item GCC online documentation:
    \href{https://gcc.gnu.org/onlinedocs/}{https://gcc.gnu.org/onlinedocs/}
    \begin{itemize}
        \item Optimize Options:
        \href{https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html}{https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html}
        \item Option Summary:
        \href{https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html}{https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html}
        \item Instrumentation Summary (including sanitizers and profilers):\\
        \href{https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html}{https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html}
    \end{itemize}
    \item GDB documentation:
    \href{https://www.sourceware.org/gdb/documentation/}{https://www.sourceware.org/gdb/documentation/}
    \item GNU Manuals Online:
    \href{https://www.gnu.org/manual/}{https://www.gnu.org/manual/}
    \item Clang 12 documentation:
    \href{https://releases.llvm.org/12.0.0/tools/clang/docs/index.html}{https://releases.llvm.org/12.0.0/tools/clang/docs/index.html}
    \begin{itemize}
        \item Change the version number in the URL to get the documentations of other versions.
    \end{itemize}
    \item LLVM documentation:
    \href{https://llvm.org/}{https://llvm.org/}
    \begin{itemize}
        \item Lots of remarkable projects can be found there!
    \end{itemize}
\end{enumerate}

\bibliographystyle{abbrv}
\bibliography{reference}

\appendix
\section{Key Programming Paradigms}
(Tip: refer to \emph{Wikipedia} for more resources.)
\subsection{Serial}
\subsubsection{Non-structured}
E.g., machine languages, assembly languages, early high-level languages with \emph{goto}.
\subsubsection{Structured}
\begin{enumerate}
    \item Imperative
    (Turing languages)
    \begin{enumerate}
        \item Procedural
        \item Object-oriented
    \end{enumerate}
    \item Declarative
    \begin{enumerate}
        \item Functional
        (Church languages)\\
        (Development: untyped $\rightarrow$ typed)
        \begin{enumerate}
            \item Impure
            \item Pure
        \end{enumerate}
        \item Logic
        (Church languages)
        \item Databases
    \end{enumerate}
\end{enumerate}
\emph{Multi-paradigmatic} languages are more and more popular.
\subsection{Parallel}
\subsubsection{Data Parallel}
\begin{enumerate}
    \item High level: vectorization
    \item Low level: SIMT
    \item Synchronization mechanisms: barriers
\end{enumerate}
\subsubsection{Task Parallel}
\begin{enumerate}
    \item Concurrency mechanism
    \begin{enumerate}
        \item High level: async/await (a.k.a., future monad)
        \item Low level:
        \begin{enumerate}
            \item multiprocessing
            \item multithreading
            \item coroutines
            \begin{enumerate}
                \item stackful
                \item stackless
            \end{enumerate}
            \item futures, promises, and others
            \item callbacks
            \item reactive extensions
        \end{enumerate}
    \end{enumerate}
    \item Synchronization mechanisms
    \begin{enumerate}
        \item Shared memory
        \item Message passing
        \item Lock-free programming (e.g., using atomic operations)
    \end{enumerate}
\end{enumerate}
\subsubsection{Distributed Computing}
\begin{enumerate}
    \item Map-Reduce
    \item Transforms-Actions (Spark)
\end{enumerate}

\section{List of Interesting and Useful Libraries and Tools}
\subsection{Protocol Buffer \& gRPC}
Protobuf:
\href{https://protobuf.dev/}{https://protobuf.dev/}

gRPC:
\href{https://grpc.io/}{https://grpc.io/}
\subsection{Google Test \& Google Mock}
\href{https://google.github.io/googletest/}{https://google.github.io/googletest/}
\subsection{OpenTelemetry}
\href{https://opentelemetry.io/}{https://opentelemetry.io/}

Some observability tools like DataDog are really nice, but they are not free.
Free ones like Jaeger are also good alternatives.
\subsection{AWS SDK}
\subsection{JAX}
\href{https://jax.readthedocs.io/en/latest/}{https://jax.readthedocs.io/en/latest/}
\end{document}
